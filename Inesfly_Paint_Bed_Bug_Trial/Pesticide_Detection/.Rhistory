bugpos<- rbind(bugpos, stout)
}
imshow(bg)
for(i in 1:max(bugpos$track)){
lines(x=bugpos$x[which(bugpos$track==i)], y=bugpos$y[which(bugpos$track==i)], col=i)
}
bugpos<- data.frame()
for (i in 1:100){
#estract individual frame
res<-getFrame(pilotvidr1, i)
#put everything into grey scale.
gryscl <- ddd2d(res)
#mask other petri dishes
mask<-blend(gryscl, pmask, "*")
#make sure background is already defined.Do not do it in the look or it will take forever.
#remove the background.
sub<-blend(nbg, mask, "-")
#set a threshold difference making image black or white
bw<-thresholding(sub, 70, "binary")
#detect the black blobs that are created
bugcords<-blobDetector(bw)
# idk what this is doing?
bugcords<-mutate(bugcords, frame = i, track = NA)
stout<-simpleTracker(past = bugpos, current = bugcords,maxDist=100)
bugpos<- rbind(bugpos, stout)
}
imshow(bg)
for(i in 1:max(bugpos$track)){
lines(x=bugpos$x[which(bugpos$track==i)], y=bugpos$y[which(bugpos$track==i)], col=i)
}
View(bugpos)
imshow(nbg)
lines(c(70,300), c(190,190), col= "red",lwd = 8)
150:400, 50:280
lines(c(70,280), c(190,200), col= "red",lwd = 4)
imshow(nbg)
lines(c(70,280), c(190,200), col= "red",lwd = 4)
lines(c(70,280), c(190,210), col= "red",lwd = 4)
imshow(bg)
imshow(nbg)
lines(c(70,280), c(190,208), col= "red",lwd = 4)
lines(c(70,280), c(192,208), col= "red",lwd = 4)
imshow(nbg)
lines(c(70,280), c(192,206), col= "red",lwd = 4)
imshow(nbg)
lines(c(70,280), c(192,204), col= "red",lwd = 4)
imshow(nbg)
lines(c(65,280), c(192,204), col= "red",lwd = 4)
y<-c(192,204)
x<-(c(65,280)
lines(x,y c, col= "red",lwd = 4)
x<-c(65,280)
lines(x,y c, col= "red",lwd = 4)
lines(x,y, col= "red",lwd = 4)
lm(y,x)
y<-c(192,204)
x<-c(65,280)
lines(x,y, col= "red",lwd = 4)
#generate line equation
lm(y,x)
lm(y~x)
?predict
line1<-lm(y~x)
names(line1)
int1<-  line1$coefficients[2]
int1
line1$coefficients
int1<-  line1$coefficients[1]
int1
predict(line1, newstuff, z)
ztab<-predict(line1, z)
z<-c(0,1,2)
ztab<-predict(line1, z)
ztab<-predict(line1)
ztab
ztab<-predict(line1, newdata=z)
ztab<-predict(newdata=z)
ztab<-predict(line1, data=z)
ztab
z
ztab<-predict(line1, z)
ztab<-predict(line1, newdata= z)
ztab<-predict(line1, newdata = z)
ztab<-predict(lm(y~x), newdata = z)
ztab<-predict(lm(y~x), newdata = x)
x
ztab<-predict(lm(y~x), newdata = 5)
ztab
imshow(nbg)
y<-c(192,204)
x<-c(65,280)
lines(x,y, col= "red",lwd = 4)
#generate line equation
line1<-lm(y~x)
int1<-  line1$coefficients[1]
slope1<-line1$coefficients[2]
above<-function{xn,yn}
pred<-int1*(xn)+slope1
prdiff<-pred-yn
if(prdiff>=0){1}
if(prdiff<0){0}
}
above <- function(xn,yn){
pred<-int1*(xn)+slope1
prdiff<-pred-yn
if(prdiff>=0){1}
if(prdiff<0){0}
}
bugpos$newtab<-sapply(bugpos$y, above)
bugpos$newtab<-sapply(xn = bugpos$x, yn = bugpos$y, above)
bugpos$newtab<-sapply(xn = bugpos$x, yn = bugpos$y, FUN=above)
bugpos$newtab<-sapply(X = c(bugpos$x, bugpos$y), FUN=above)
fits <- function(xn){
pred<-int1*(xn)+slope1
prdiff<-pred-yn
}
bugpos$newtab<-sapply(bugpos$x, FUN=fits)
fits <- function(xn){
pred<-int1*(xn)+slope1
}
bugpos$newtab<-sapply(bugpos$x, FUN=fits)
fits <- function(yn){
pred<-int1*(xn)+slope1
if(pred>y){nv<-1}
if(pred<=y){nv<-0}
nv
}
fits <- function(xn){
pred<-int1*(xn)+slope1
}
bugpos$pred<-sapply(bugpos$x, FUN=fits)
above <- function(yn){
pred<-int1*(xn)+slope1
if(pred>y){nv<-1}
if(pred<=y){nv<-0}
nv
}
bugpos$onpest<-sapply(bugpos$y, FUN=fits)
View(bugpos$onpest)
View(bugpos)
slope1<-((y[2]-y[1])/(x[2]-x[1]))
slope1
int1<-  (line1$coefficients[1])
int1
fits <- function(xn){
pred<-slope1*(xn)+int1
}
bugpos$pred<-sapply(bugpos$x, FUN=fits)
above <- function(yn){
pred<-int1*(xn)+slope1
if(pred>y){nv<-1}
if(pred<=y){nv<-0}
nv
}
slope1
fits <- function(xn){
pred<-slope1*(xn)+int1
pred
}
bugpos$pred<-sapply(bugpos$x, FUN=fits)
View(bugpos)
bugpos$pred<-int1*(xn)+slope1
below<-which(bugpos$y<bugpos$pred)
above<-which(bugpos$y>=bugpos$pred)
bugpos$onpest[above]<-1
bugpos$onpest[below]<-0
View(bugpos)
imshow(nbg)
y<-c(192,204)
x<-c(65,280)
lines(x,y, col= "red",lwd = 4)
line1<-lm(y~x)
slope1<-((y[2]-y[1])/(x[2]-x[1]))
imshow(pmask)
??getpoly
install.package("splancs")
install.packages("splancs")
library(splancs)
mypoly<-getpoly()
ports
quartz()
imshow(nbg)
mypoly<-getpoly()
my poly
mypoly
mypoly<-getpoly()
mypoly
inout
inout(mypoly,mat)
inout(mat,mypoly)
inmypoly<-inout(mat,mypoly)
pmask <- (r2img(inmypoly))
nbg<-blend(bg, inmypoly, "*")
max <- matrix(inmypoly, nrow = bg$dim[1], ncol = bg$dim[2])
maxpol <- matrix(inmypoly, nrow = bg$dim[1], ncol = bg$dim[2])
#make the matrix into an image
pmask <- (r2img(maxpol))
imshow(pmask)
mypoly
dim(mat)
?inout
mat
mat <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
View(mat)
dim(mat)
dim(mat)[1]
dim(mat)[2]
#go through matrix and ask if it is in or out of the polygon
inorout <- matrix(inorout, nrow = bg$dim[1], ncol = bg$dim[2])
for(i in 1:max(dim(mat[1]))){
for(j in 1:max(dim(mat[2]))){
inorout[i,j]<-inout(c(i,j), mypoly)
}
}
dim(mat[1])
mat
dim(mat)
dim(mat[1])
dim(mat[1,])
dim(mat[,1])
dim(mat)[1]
for(i in 1:max(dim(mat)[1])){
for(j in 1:max(dim(mat)[2])){
inorout[i,j]<-inout(c(i,j), mypoly)
}
}
?as.points
as.points(c(1,2))
as.points(c(1,2), c(3,4))
as.points(c(1,2,4), c(3,4,5))
as.points(c(1), c(3))
inorout <- matrix(inorout, nrow = bg$dim[1], ncol = bg$dim[2])
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[i,j]<-inout(point, mypoly)
}
}
inorout <- matrix( 0, nrow = bg$dim[1], ncol = bg$dim[2])
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[i,j]<-inout(point, mypoly)
}
}
inorout
which(inorout==1)
pmask <- (r2img(inorout))
nbg<-blend(bg, pmask, "*")
imshow(nbg)
#get polygon
mypoly<-getpoly()
inmypoly<-inout(mat,mypoly)
maxpol <- matrix(inmypoly, nrow = bg$dim[1], ncol = bg$dim[2])
inorout <- matrix( 0, nrow = bg$dim[1], ncol = bg$dim[2])
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[k,j]<-inout(point, mypoly)
}
}
#make the matrix into an image
pmask <- (r2img(inorout))
mypoly
inmypoly<-inout(mat,mypoly)
maxpol <- matrix(inmypoly, nrow = bg$dim[1], ncol = bg$dim[2])
inorout <- matrix( 0, nrow = bg$dim[1], ncol = bg$dim[2])
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[k,j]<-inout(point, mypoly)
}
}
inmypoly<-inout(mat,mypoly)
maxpol <- matrix(inmypoly, nrow = bg$dim[1], ncol = bg$dim[2])
inorout <- matrix( 0, nrow = bg$dim[1], ncol = bg$dim[2])
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[j,i]<-inout(point, mypoly)
}
}
inmypoly<-inout(mat,mypoly)
maxpol <- matrix(inmypoly, nrow = bg$dim[1], ncol = bg$dim[2])
inorout <- matrix( 0, nrow = bg$dim[1], ncol = bg$dim[2])
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[i,j]<-inout(point, mypoly)
}
}
pmask <- (r2img(inorout))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
imshow(pmask)
inmypoly<-inout(mat,mypoly)
inorout <- matrix( 0, nrow = bg$dim[1], ncol = bg$dim[2])
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[dim[i,dim[2]+1-j]<-inout(point, mypoly)
}
}
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[i,(dim[2]+1-j)]<-inout(point, mypoly)
}
}
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[i,(dim(bg)[2]+1-j)]<-inout(point, mypoly)
}
}
pmask <- (r2img(inorout))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
pmask <- (r2img(inorout))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(pmask)
quartz()
pmask <- (r2img(inorout))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
imshow(bg)
mypoly<-getpoly()
mypoly
inorout <- matrix( 0, nrow = bg$dim[1], ncol = bg$dim[2])
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[i,(dim(bg)[2]+1-j)]<-inout(point, mypoly)
}
}
pmask <- (r2img(inorout))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
inorout
inorout <- matrix( 0, nrow = bg$dim[1], ncol = bg$dim[2])
inorout2<- inorout
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[i,j)] <- inout(point, mypoly)
}
}
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[i,j] <- inout(point, mypoly)
}
}
pmask <- (r2img(inorout))
nbg<-blend(bg, pmask, "*")
imshow(nbg)
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout2[i,dim(max)[2]-j+1)] <- inout(point, mypoly)
}
}
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout2[i,(dim(mat)[2]-j+1)] <- inout(point, mypoly)
}
}
pmask <- (r2img(inorout2))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout2[(dim(mat)[2]-i+1),i] <- inout(point, mypoly)
}
}
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout2[(dim(mat)[1]-i+1),j] <- inout(point, mypoly)
}
}
#make the matrix into an image
#quartz()
pmask <- (r2img(inorout2))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
imshow(bg)
imshow(nbg)
pmask <- (r2img(inorout))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
head(mat)
dim(mat)
mat[1,1]
dim(inorout)
dim(bg)
dim(imshow(bg))
bg$dim
pmask <- (r2img(inorout))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
pmask <- (r2img(inorout))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(bg)
mypoly<-getpoly()
inorout  <- matrix( 0, nrow = bg$dim[1], ncol = bg$dim[2] )
inorout2 <- inorout
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout[i,j] <- inout(point, mypoly)
}
}
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(c(i), c(j))
inorout2[(dim(mat)[1]-i+1),j] <- inout(point, mypoly)
}
}
#make the matrix into an image
#quartz()
pmask <- (r2img(inorout))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
pmask <- (r2img(inorout2))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
plot(mypoly)
imshow(bg)
poly(myplot)
poly(myploy)
poly(mypoly)
?poly
?imshow
?blend
points(bugpos$x, bugpos$y)
y<-c(192,204)
x<-c(65,280)
lines(x,y, col= "red",lwd = 4)
points(mypoly)
points(mypoly, col="red")
mypoly
inorout  <- matrix( 0, nrow = bg$dim[1], ncol = bg$dim[2] )
inorout2 <- inorout
for(i in 1:dim(mat)[1]){
for(j in 1:dim(mat)[2]){
point<-as.points(i,j)
if (inout(point, mypoly)==TRUE) inorout[i,j] <- 1
}
}
inorout
dim(inourout)
dim(inorout)
?quartz
quartz(height=3, width=6)
quartz(height=3, width=6)
pmask <- (r2img(inorout1))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
pmask <- (r2img(inorout))
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
quartz
imshow(bg)
quartz(1,2)
quartz(height=1, width=2)
require(raster)
install.packages("raster")
mat <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
#sadly, for each dish we need to define the area by hand.
mat[150:400, 50:280] <- 1
View(mat)
pmaska <- (r2img(mat))
#now bring the mask and the background together
nbga<-blend(bg, pmaska, "*")
imshow(nbga)
dim(nbga)
nbga$dim
names(nbga)
head(nbga)
bg$dim[1]
nbga$dim[1]
nbga$dim[2]
bg$dim[2]
pmask <- r2img(inorout)
dim(pmask)
pmask$dim
nbg<-blend(bg, pmask, "*")
nbg$dim
imshow(nbg)
mat <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat <- matrix(1, nrow = bg$dim[1], ncol = bg$dim[2])
pmask <- r2img(mat)
#now bring the mask and the background together
nbg<-blend(bg, pmask, "*")
imshow(nbg)
