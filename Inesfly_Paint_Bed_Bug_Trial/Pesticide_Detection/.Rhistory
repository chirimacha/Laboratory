?install.R
library(installR)
library(install.R)
library(updateR)
library(update.R)
version()
a<-1
b<-2
a+b
install.packages("videoplayR")
??videoplayR
install.packages("OpenCV")
if (!require(devtools)) {
install.packages("devtools")
}
devtools::install_github("swarm-lab/videoplayR")
library(videoplayR)
library(devtools)
devtools::install_github("swarm-lab/videoplayR")
devtools::install_github("swarm-lab/videoplayR")
devtools::install_github("swarm-lab/videoplayR")
install.packages("lippicv")
install.packages("-lippicv")
install.packages("videoplayR")
if (!require(devtools)) {
install.packages("devtools")
}
devtools::install_github("swarm-lab/videoplayR")
library(videoplayR)
devtools::install_github("swarm-lab/videoplayR")
install.packages("devtools")
install.packages("devtools")
devtools::install_github("swarm-lab/videoplayR")
library(videoplayR)
library(dplyr)
library(clue)
library(shiny)
library(splancs)
pilotvid   <- readVid("PetriDishPilots.mp4")
pilotvidr1 <- readVid("PilotPetriRound1.mp4")
marchpilot <- readVid("MarchPilot.mp4")
setwd("/Users/mzlevy/Laboratory/Inesfly_Paint_Bed_Bug_Trial/Pesticide_Detection")
#bring in video(s)
pilotvid   <- readVid("PetriDishPilots.mp4")
pilotvidr1 <- readVid("PilotPetriRound1.mp4")
marchpilot <- readVid("MarchPilot.mp4")
pdiff <- function(a, b) {
nr <- length(a)
nc <- length(b)
ma <- matrix(a, nrow = nr, ncol = nc)
mb <- matrix(b, nrow = nr, ncol = nc, byrow = TRUE)
ma - mb
}
# declare variables in the function name
# what are current and past? defined elsewhere?
simpleTracker <- function(current, past, lookBack = 30, maxDist = 10) { #assign lookBack and maxDist w/ immutable numbers?
if (nrow(past) == 0) {
current$track <- 1:nrow(current)
return(current)
}
i <- current$frame[1]
trackCounter <- max(past$track)
# past <- dplyr::filter(past, frame > (i - lookBack), frame < i)
mat <- abs(pdiff(current$x, past$x)) + abs(pdiff(current$y, past$y))
maxMat <- matrix(maxDist * (i - past$frame), nrow = nrow(current), ncol = nrow(past), byrow = TRUE)
validMat <- mat <= maxMat
h <- as.vector(clue::solve_LSAP(mat))
tracks <- past$track[h]
valid <- validMat[(h - 1) * nrow(mat) + 1:nrow(mat)]
if (any(!valid)) {
nNew <- sum(!valid)
tracks[!valid] <- trackCounter + 1:nNew
trackCounter <- trackCounter + nNew
}
dup <- duplicated(tracks) | duplicated(tracks, fromLast = TRUE)
safe <- !dup
h[safe] <- 0
while (any(dup)) {
safe[which.max(h)] <- TRUE
h[safe] <- 0
newCurrent <- current[!safe, ]
newPast <- dplyr::filter(past, !(track %in% tracks[safe]))
if (nrow(newCurrent) > nrow(newPast)) {
n <- nrow(newCurrent) - nrow(newPast)
newPast <- rbind(newPast, data.frame(id = NA, x = rep(-9999, n), y = rep(-9999, n),
alpha = NA, major = NA, minor = NA, area = NA,
frame = newCurrent$frame[1], track = NA))
}
mat <- abs(pdiff(newCurrent$x, newPast$x)) + abs(pdiff(newCurrent$y, newPast$y))
maxMat <- matrix(maxDist * (i - newPast$frame), nrow = nrow(newCurrent),
ncol = nrow(newPast), byrow = TRUE)
validMat <- mat <= maxMat
newH <- as.vector(clue::solve_LSAP(mat))
newTracks <- newPast$track[newH]
valid <- validMat[(newH - 1) * nrow(mat) + 1:nrow(mat)]
if (any(!valid)) {
nNew <- sum(!valid)
newTracks[!valid] <- trackCounter + 1:nNew
trackCounter <- trackCounter + nNew
}
tracks[!safe] <- newTracks
dup <- duplicated(tracks) | duplicated(tracks, fromLast = TRUE)
safe <- !dup
h[safe] <- 0
}
current$track <- tracks
current
}
pipeline <- function(video, begin, end, background, mask = NULL,
threshold, minSize, lookBack, maxDist, progress = FALSE) {
n <- (end - begin + 1)
tracks <- data.frame(id = numeric(n), x = numeric(n), y = numeric(n),
alpha = numeric(n), major = numeric(n), minor = numeric(n),
area = numeric(n), frame = numeric(n) - 2 * lookBack, track = numeric(n))
pos <- 0
if (progress) {
pb <- shiny::Progress$new()
on.exit(pb$close())
pb$set(message = "Computing tracks", value = 0, detail = "0%")
nFrames <- length(begin:end)
old <- 0
oldFrame <- begin
oldTime <- Sys.time()
}
for (i in begin:end) {
past <- dplyr::filter(tracks, frame > (i - lookBack) & frame < i)
tmp <- getFrame(video, i) %>%
ddd2d() %>%
blend(background, ., "-") %>%
{if (is.null(mask)) . else blend(., mask, "*")} %>%
thresholding(threshold, "binary") %>%
blobDetector() %>%
dplyr::filter(area >= minSize) %>%
dplyr::mutate(frame = i, track = NA) %>%
{if (length(.$x) > 0)
trackR::simpleTracker(., past, lookBack = lookBack, maxDist = maxDist)
else . }
nRows <- nrow(tmp)
if (nRows > 0) {
if ((pos + nRows) > n) {
tracks[(n + 1):(2 * n + nRows), ] <- 0
n <- nrow(tracks)
}
tracks[(pos + 1):(pos + nRows), ] <- tmp
pos <- pos + nRows
}
if (progress) {
new <- floor(100 * (i - begin + 1) / nFrames)
if (new > old) {
newTime <- Sys.time()
fps <- (i - oldFrame + 1) / as.numeric(difftime(newTime, oldTime, unit = "secs"))
old <- new
oldFrame <- i
oldTime <- newTime
pb$set(value = old / 100, detail = paste0(old, "% - ", round(fps, digits = 2), "fps"))
}
}
}
tracks[1:pos, ]
}
#Try to create the background once, this takes too long, especially if median is used.
bg <- backgrounder(pilotvidr1, n = 100, method = "mean", color = FALSE)
bugpos<- data.frame()
#Create "mask" that only allows one petri dish to be analyzed at a time
mat <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
#sadly, for each dish we need to define the area by hand.
mat[150:400, 50:280] <- 1
#go through matrix and ask if it is in or out of the polygon
pmaska <- (r2img(mat))
#now bring the mask and the background together
nbga<-blend(bg, pmaska, "*")
imshow(nbga)
#get polygon
#mypoly<-getpoly()
#mypoly2<-getpoly
mbg <- backgrounder(marchpilot, n = 100, method = "mean", color = FALSE)
#create a blank data frame for loop output
marbugpos <- data.frame()
###Each quadrant will have to build upon
#Quadrant 2
mmat <- matrix(0, nrow = mbg$dim[1], ncol = mbg$dim[2])
#sadly, for each dish we need to define the area by hand.
mmat[150:268, 370:480] <- 1
#go through matrix and ask if it is in or out of the polygon
pmaskm <- (r2img(mmat))
#now bring the mask and the background together
nbgm<-blend(mbg, pmaskm, "*")
imshow(nbgm)
names(marchpilot)
marchpilot$dim
marchpilot$length
for (i in 1:marchpilot(marchpil)){
#extract individual frames
res<-getFrame(marchpilot, i)
#put frame into grey scale.
gryscl <- ddd2d(res)
#mask other petri dishes
mask<-blend(gryscl, pmaskm, "*")
#subtract background from the mask. Only movement will show
sub<-blend(nbgm, mask, "-")
#set a threshold difference to remove changes due to glare/reflection
bw<-thresholding(sub, 50, "binary")
#detect the black blobs that are created. Get coordinates
bugcords<-blobDetector(bw)
# add track # to data frame
if(nrow(bugcords)>0) {
bugcords<-mutate(bugcords, frame = i, track = NA)
#determines what points are linked. Optimally each insect given 1 track each
#because there is only one object, we can max out maxDist.
stout<-simpleTracker(past = marbugpos, current = bugcords, maxDist=1000)
#combine tables previous in the loop.
marbugpos<- rbind(marbugpos, stout)
}
#do we want to add an else value? idk if it will mess up simpleTracker
}
marchpilot
for (i in 1:marchpilot$length){
#extract individual frames
res<-getFrame(marchpilot, i)
#put frame into grey scale.
gryscl <- ddd2d(res)
#mask other petri dishes
mask<-blend(gryscl, pmaskm, "*")
#subtract background from the mask. Only movement will show
sub<-blend(nbgm, mask, "-")
#set a threshold difference to remove changes due to glare/reflection
bw<-thresholding(sub, 50, "binary")
#detect the black blobs that are created. Get coordinates
bugcords<-blobDetector(bw)
# add track # to data frame
if(nrow(bugcords)>0) {
bugcords<-mutate(bugcords, frame = i, track = NA)
#determines what points are linked. Optimally each insect given 1 track each
#because there is only one object, we can max out maxDist.
stout<-simpleTracker(past = marbugpos, current = bugcords, maxDist=1000)
#combine tables previous in the loop.
marbugpos<- rbind(marbugpos, stout)
}
#do we want to add an else value? idk if it will mess up simpleTracker
}
imshow(nbgm)
marbugpos
imshow(nbgm)
nbgm
y<-c(192,204)
x<-c(65,280)
lines(x,y, col= "red",lwd = 4)
imshow(nbgm)
y<-c(192,204)
x<-c(65,280)
lines(x,y, col= "red",lwd = 2)
imshow(nbgm)
y<-c(60,204)
x<-c(300,300)
lines(x,y, col= "red",lwd = 2)
y<-c(50,204)
imshow(nbgm)
y<-c(250,404)
x<-c(500,500)
lines(x,y, col= "red",lwd = 2)
}
imshow(nbgm)
y<-c(350,420)
x<-c(450,500)
lines(x,y, col= "red",lwd = 1)
imshow(nbgm)
y<-c(250,420)
x<-c(430,430)
lines(x,y, col= "red",lwd = 1)
y<-c(260,340)
x<-c(430,430)
lines(x,y, col= "red",lwd = 1)
imshow(nbgm)
y<-c(260,340)
x<-c(430,430)
lines(x,y, col= "red",lwd = 1)
imshow(nbgm)
y<-c(260,340)
x<-c(430,430)
lines(x,y, col= "red",lwd = 1)
imshow(nbgm)
y<-c(260,340)
x<-c(430,430)
lines(x,y, col= "red",lwd = 1)
imshow(nbgm)
y<-c(260,340)
x<-c(430,430)
lines(x,y, col= "red",lwd = 1)
imshow(nbgm)
y<-c(260,340)
x<-c(420,420)
lines(x,y, col= "red",lwd = 1)
imshow(nbgm)
y<-c(220,340)
x<-c(424,424)
lines(x,y, col= "red",lwd = 1)
imshow(nbgm)
y<-c(224,320)
x<-c(420,422)
lines(x,y, col= "red",lwd = 1)
imshow(nbgm)
y<-c(224,320)
x<-c(422,422)
lines(x,y, col= "red",lwd = 1)
imshow(nbgm)
y<-c(224,320)
x<-c(423,421)
lines(x,y, col= "red",lwd = 1)
imshow(nbgm)
ya<-c(224,320)
xa<-c(423,421)
lines(xa,ya, col= "red",lwd = 1)
#generate line equation
line1a<-lm(y~x)
slope1a<-((y[2]-y[1])/(x[2]-x[1]))
int1a<-  (line1a$coefficients[1])
#generate where the line y is depending on the x of the bug.
fits <- function(xn){
pred<-slope1a*(xn)+int1a
pred
}
bugpos$pred<-sapply(bugpos$x, FUN=fits)
#determine if y of bug is above or below line (differnet from predicted y)
below<-which(bugpos$y<bugpos$pred)
above<-which(bugpos$y>=bugpos$pred)
bugpos$onpest[above]<-1
bugpos$onpest[below]<-0
320-224
96/2
224
224+48
423-48
423+48
imshow(nbgm)
ya<-c(224,320)
xa<-c(423,421)
lines(xa,ya, col= "red",lwd = 1)
#In the future I will need to do the same thing in x chord.
yb<-c(272,272) #96
xb<-c(375,471)
lines(xb,yb, col= "red",lwd = 1)
slope1a<-((ya[2]-ya[1])/(xa[2]-xa[1]))
line1a
line1a$slope
names(line1a)
line1a$coefficients[1]
line1a$coefficients[2]
predict(line1a, marbugpos$x)
predict(line1a, marbugpos$x, na.rm=TRUE)
predict(line1a, xa=marbugpos$x, na.rm=TRUE)
marbugpos
predict(line1a, xa=marbugpos$x, na.rm=TRUE)
asdf<-predict(line1a, xa=marbugpos$x, na.rm=TRUE)
asdf
View(asdf)
marbugpos$x
asdf<-predict(line1a, xa=marbugpos$x)
asdf
line1a
asdf<-predict(object=line1a, xa=marbugpos$x)
asf
asdf
new<-data.frame(xa==marbugpos$x)
new<-data.frame(xa = marbugpos$x)
new
news<-data.frame(xa = marbugpos$x)
predict(line1a, news, na.rm=TRUE
)
news<-data.frame(xa = marbugpos$x)
predict(line1a, news, na.rm=TRUE)
names(new)
line1a
line1a<-lm(ya~xa)
slope1a<-((ya[2]-ya[1])/(xa[2]-xa[1]))
int1a<-  (line1a$coefficients[1a])
predict(line1a, news, na.rm=TRUE)
line1a<-lm(ya~xa)
line1b<-lm(yb~xb)
newsa<-data.frame(xa = marbugpos$x)
newsb<-data.frame(ya = marbugpos$y)
marbugpos$pred1 <- predict(line1a, newsa, na.rm=TRUE)
marbugpos$pred2 <- predict(line1b, newsb, na.rm=TRUE)
predict(line1a, newsa, na.rm=TRUE)
View(predict(line1a, newsa, na.rm=TRUE))
cim(predict(line1a, newsa, na.rm=TRUE))
dim(predict(line1a, newsa, na.rm=TRUE))
length(predict(line1a, newsa, na.rm=TRUE))
dim(marpilotvidr)
dim(marchpilot)
dim(marbugpos)
marbugpos$pred1 <- predict(line1a, newsa, na.rm=TRUE)
marbugpos$pred2 <- predict(line1b, newsb, na.rm=TRUE)
marbugpos$pred2 <- predict(line1b, yb=newsb, na.rm=TRUE)
newsb<-data.frame(xb = marbugpos$x)
marbugpos$pred2 <- predict(line1b, newsb, na.rm=TRUE)
below<-which(marbugpos$y<marbugpos$pred1)
above<-which(marbugpos$y>=marbugpos$pred1)
marbugpos$onpest1[above]<-1
marbugpos$onpest1[below]<-0
below<-which(marbugpos$y<marbugpos$pred2)
above<-which(marbugpos$y>=marbugpos$pred2)
marbugpos$onpest2[above]<-1
marbugpos$onpest2[below]<-0
View(marbugpos)
