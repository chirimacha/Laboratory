# aMXR <-c(,,,,,)
# aMYT <-c(,,,,,)
# aMYB <-c(,,,,,)
# aTPX <-c(,,,,,)
# aTPY <-c(,,,,,)
# aBPX <-c(,,,,,)
# aBPY <-c(,,,,,)
# aLPX <-c(,,,,,)
# aLPY <-c(,,,,,)
# aRPX <-c(,,,,,)
# aRPY <-c(,,,,,)
# #c(,,,,,)
# #create a coordinate table
# CoTbR1T1C1<-data.frame(Tray, aMXL, aMXR, aMYT, aMYB, aBPX, aBPY, aTPX, aTPY,
#                        aRPX, aRPY, aLPX, aLPY)
# #rename so that colums can be found in function
# names(CoTbR1T1C1)<-c(Tray,MXL, MXR, MYT, MYB, BPX, BPY, TPX, TPY,
#                      RPX, RPY, LPX, LPY)
#Video FR1T1C2
#tray number
Tray<-c(1,2,3,4,5,6)
#Left Matrix limit for mask
bMXL <-c(168, 351, 521, 178, 349, 517)
#right Matrix limit for mask
bMXR <-c(351, 521, 703, 349, 517, 703)
#Top matrix limit
bMYT <-c(427, 427, 427, 238, 238, 238)
#bottom matrix limit
bMYB <-c(238, 238, 238,  59,  59,  59)
#Top point of vericle line (X-Coord)
bTPX <-c(258, 434, 608, 267, 439, 596)
#Top point of verticle line (Y-Coord)
bTPY <-c(404, 406, 410, 224, 224, 219)
#Bottom Point
bBPX <-c(284, 439, 604, 276, 438, 601)
bBPY <-c(254, 255, 252,  87,  82,  77)
#Left Point of horizontal line
bLPX <-c(199, 363, 532, 198, 362, 527)
bLPY <-c(316, 329, 330, 153, 155, 150)
#Right Point of Horizontal line
bRPX <-c(338, 511, 685, 337, 515, 678)
bRPY <-c(338, 331, 333, 158, 154, 155)
#c(,,,,,)
#create a coordinate table
CoTbR1T1C2<-data.frame(Tray, bMXL, bMXR, bMYT, bMYB, bBPX, bBPY, bTPX, bTPY,
bRPX, bRPY, bLPX, bLPY)
#rename so values are easily called in loop or function
names(CoTbR1T1C2)<-c("Tray","MXL", "MXR", "MYT", "MYB", "BPX", "BPY", "TPX", "TPY",
"RPX", "RPY", "LPX", "LPY")
###############################################################################
#create background.  Do this step only once
bg<- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# bg <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
# <- backgrounder(R1T1C2, n = 1600, method = "mean", color = FALSE)
#Takes in the video and coordinate table to
#output the coordinates of the insect in each frame for all 6 bugs
VidAnalysis<-function(video, coordtab, thresholda, maxDistb, cam, rep, trial){
#create the background
#bg <- backgrounder(video, n = 1800, method = "mean", color = FALSE)
#create black masks to isolate each petridish using matrix
mat1 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat2 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat3 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat4 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat5 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat6 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
#create whole for each petridish in each mask
#sadly, for each dish we need to define the area by hand.
#mat works left to right, but top to bottom.
#Graphing works bottom to top so we need correction
mat1[((bg$dim[1])-coordtab$MYT[1]):((bg$dim[1])-coordtab$MYB[1]),
coordtab$MXL[1]:coordtab$MXR[1]] <- 1
mat2[((bg$dim[1])-coordtab$MYT[2]):((bg$dim[1])-coordtab$MYB[2]),
coordtab$MXL[2]:coordtab$MXR[2]] <- 1
mat3[((bg$dim[1])-coordtab$MYT[3]):((bg$dim[1])-coordtab$MYB[3]),
coordtab$MXL[3]:coordtab$MXR[3]] <- 1
mat4[((bg$dim[1])-coordtab$MYT[4]):((bg$dim[1])-coordtab$MYB[4]),
coordtab$MXL[4]:coordtab$MXR[4]] <- 1
mat5[((bg$dim[1])-coordtab$MYT[5]):((bg$dim[1])-coordtab$MYB[5]),
coordtab$MXL[5]:coordtab$MXR[5]] <- 1
mat6[((bg$dim[1])-coordtab$MYT[6]):((bg$dim[1])-coordtab$MYB[6]),
coordtab$MXL[6]:coordtab$MXR[6]] <- 1
#Make Mask Matrix into an image
pmaska <- (r2img(mat1))
pmaskb <- (r2img(mat2))
pmaskc <- (r2img(mat3))
pmaskd <- (r2img(mat4))
pmaske <- (r2img(mat5))
pmaskf <- (r2img(mat6))
#now bring the mask and the background together
nbga1<-blend(bg, pmaska, "*")
nbga2<-blend(bg, pmaskb, "*")
nbga3<-blend(bg, pmaskc, "*")
nbga4<-blend(bg, pmaskd, "*")
nbga5<-blend(bg, pmaske, "*")
nbga6<-blend(bg, pmaskf, "*")
#Create Function that finds the coordinate of the insect in each quadrant in each frame
Coords<-function(video, pmask, nbga, coordtaba, tn, threshold, maxDista, rep, cam){
#determine loop length
#     if (video$length<1800) {
#       fr <- video$length
#     } else {
#       fr<-1800
#     }
#temporarily set fr to 20 to speed up code while debugging.
fr<-20
#Reset bugpos to blank data frame
bugpos<-data.frame()
for (i in 1:fr){
#extract individual frames
res<-getFrame(video, i)
#put frame into grey scale.
gryscl <- ddd2d(res)
#mask other petri dishes
mask<-blend(gryscl, pmask, "*")
#subtract background from the mask. Only movement will show
sub<-blend(nbga, mask, "-")
#set a threshold difference to remove changes due to glare/reflection/noise
bw<-thresholding(sub, threshold, "binary")
#detect the white blobs that are created. Get coordinates
bugcords<-blobDetector(bw)
# add track # to data frame only if a change is detected
if(nrow(bugcords)>0) {
bugcords<-mutate(bugcords, frame = i, track = NA)
#determines what points are linked. Optimally each insect given 1 track each
#because there is only one object, we can max out maxDist.
stout<-simpleTracker(past = bugpos, current = bugcords, maxDist = maxDista)
#combine tables previous in the loop.
bugpos<- rbind(bugpos, stout)
}
}
ya<-c(coordtaba$BPY[tn],coordtaba$TPY[tn])
xa<-c(coordtaba$BPX[tn],coordtaba$TPX[tn])
# #In the future I will need to do the same thing in x chord.
yb<-c(coordtaba$LPY[tn],coordtab$RPY[tn]) #96
xb<-c(coordtaba$LPX[tn],coordtab$RPX[tn])
#generate line equation
line1a<-lm(ya~xa)
line1b<-lm(yb~xb)
#obtain data for prediction
newsa<-data.frame(xa = bugpos$x)
newsb<-data.frame(xb = bugpos$x)
#predict the location of line at specified location
bugpos$pred1 <- predict(line1a, newsa, na.rm=TRUE)
bugpos$pred2 <- predict(line1b, newsb, na.rm=TRUE)
#     #determine if bug is above or below line (differnet from predicted y)
#     belowa<-which((bugpos$y) <  (bugpos$pred1))
#     abovea<-which((bugpos$y) >= (bugpos$pred1))
#     belowb<-which((bugpos$y) <  (bugpos$pred2))
#     aboveb<-which((bugpos$y) >= (bugpos$pred2))
#     which()
# # Determine Quadrants #change depending on slope of verticle line
#     if((coordtab$TPX[tn]) > (coordtab$BPX[tn])) {
#       bugpos$quad[intersect(belowa,aboveb)]<-1
#       bugpos$quad[intersect(abovea,aboveb)]<-4
#       bugpos$quad[intersect(belowa,belowb)]<-2
#       bugpos$quad[intersect(abovea,belowb)]<-3
#     } else {
#       bugpos$quad[intersect(abovea,aboveb)]<-1
#       bugpos$quad[intersect(belowa,aboveb)]<-4
#       bugpos$quad[intersect(abovea,belowb)]<-2
#       bugpos$quad[intersect(belowa,belowb)]<-3
#     }
#indicate the tray in data table.
bugpos$trayn<-tn
#return the data table.
return(bugpos)
}
#Now run this subfunction over the 6 dishes
pdt1 <-Coords(video, pmaska, nbga1, coordtaba=coordtab, tn=1,
threshold=thresholda, maxDista=maxDistb)
pdt2 <-Coords(video, pmaskb, nbga2, coordtaba=coordtab, tn=2,
threshold=thresholda, maxDista=maxDistb)
pdt3 <-Coords(video, pmaskc, nbga3, coordtaba=coordtab, tn=3,
threshold=thresholda, maxDista=maxDistb)
pdt4 <-Coords(video, pmaskd, nbga4, coordtaba=coordtab, tn=4,
threshold=thresholda, maxDista=maxDistb)
pdt5 <-Coords(video, pmaske, nbga5, coordtaba=coordtab, tn=5,
threshold=thresholda, maxDista=maxDistb)
pdt6 <-Coords(video, pmaskf, nbga6, coordtaba=coordtab, tn=6,
threshold=thresholda, maxDista=maxDistb)
#Bind All the tables
MasterTab<-rbind(pdt1, pdt2, pdt3, pdt4, pdt5, pdt6)
#indicate which camera this is
MasterTab$camera<-cam
#Indicate which repetition
MasterTab$rep<-rep
MasterTab$trial<-trial
MasterTab$position<-(MasterTab$trayn)+(6*(cam-1))
#Output as single data table
return(MasterTab)
}
###############################################################################
#run
#DR1T1C1<-VidAnalysis(video=R1T1C2, coordtab=CoTbR1T1C1, thresholda=50,
#              maxDistb=1000)
DR1T1C2<-VidAnalysis(video=R1T1C2, coordtab=CoTbR1T1C2, thresholda=50,
maxDistb=1000, cam=2, rep=1, trial=1)
write.csv(DR1T1C2, "Rep1Trial1Cam2RawData.csv")
Assign<-function(VidData, CoordData, trayData){
belowa <- which((VidData$y) <  (VidData$pred1))
abovea <- which((VidData$y) >= (VidData$pred1))
belowb <- which((VidData$y) <  (VidData$pred2))
aboveb <- which((VidData$y) >= (VidData$pred2))
NegSlope <- which(CoordData$TPX <  CoordData$BPX )
PosSlope <- which(CoordData$TPX >= CoordData$BPX )
negs<-which(is.na(match(NegSlope, VidData$trayn))==FALSE)
poss<-which(is.na(match(PosSlope, VidData$trayn))==FALSE)
# Determine Quadrants #change depending on slope of verticle line
# In cases of positive slopes
VidData$quad<-NA
VidData$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
VidData$quad[intersect( poss, (intersect(abovea,aboveb)))]<-4
VidData$quad[intersect( poss, (intersect(belowa,belowb)))]<-2
VidData$quad[intersect( poss, (intersect(abovea,belowb)))]<-3
VidData$quad[intersect( negs, (intersect(abovea,aboveb)))]<-1
VidData$quad[intersect( negs, (intersect(belowa,aboveb)))]<-4
VidData$quad[intersect( negs, (intersect(abovea,belowb)))]<-2
VidData$quad[intersect( negs, (intersect(belowa,belowb)))]<-3
###Create function that determines which quadrants have pesticide
for (i in 1:length(VidData$quad)){
r <- which(trayData$Repetition==VidData$rep[i])
t <- which(trayData$Trial==VidData$trial[i])
p <- which(trayData$Position==VidData$position[i])
id <- intersect( p, intersect(r, t))
VidData$DishID[i] <- trayData$DishID[id]
VidData$Orientation[i] <- trayData$Orientation[id]
#there has to be a better way to do this
one   <- c(1,2,3,4)
two   <- c(2,3,4,1)
three <- c(3,4,1,2)
four  <- c(4,1,2,3)
OTab  <- data.frame(one, two, three, four)
Or    <- which(OTab$one==VidData$Orientation[i])
VidData$PQuad[i] <- OTab[Or, VidData$Orientation[i]]
#I'm pretty sure the above 7 lines could be two.
}
uno<-which(VidData$PQuad==1)
dos<-which(VidData$PQuad==2)
tres<-which(VidData$PQuad==3)
cuatro<-which(VidData$PQuad==4)
VidData$Pesticide[uno]<-0
VidData$Pesticide[dos]<-1
VidData$Pesticide[tres]<-0
VidData$Pesticide[cuatro]<-1
return(VidData)
}
#=============
tryit<-Assign(VidData = DR1T1C2, CoordData = CoTbR1T1C2, trayData = TrayPlace)
Assign<-function(VidData, CoordData, trayData){
belowa <- which((VidData$y) <  (VidData$pred1))
abovea <- which((VidData$y) >= (VidData$pred1))
belowb <- which((VidData$y) <  (VidData$pred2))
aboveb <- which((VidData$y) >= (VidData$pred2))
NegSlope <- which(CoordData$TPX <  CoordData$BPX )
PosSlope <- which(CoordData$TPX >= CoordData$BPX )
negs<-which(is.na(match(NegSlope, VidData$trayn))==FALSE)
poss<-which(is.na(match(PosSlope, VidData$trayn))==FALSE)
# Determine Quadrants #change depending on slope of verticle line
# In cases of positive slopes
VidData$quad<-NA
VidData$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
VidData$quad[intersect( poss, (intersect(abovea,aboveb)))]<-4
VidData$quad[intersect( poss, (intersect(belowa,belowb)))]<-2
VidData$quad[intersect( poss, (intersect(abovea,belowb)))]<-3
VidData$quad[intersect( negs, (intersect(abovea,aboveb)))]<-1
VidData$quad[intersect( negs, (intersect(belowa,aboveb)))]<-4
VidData$quad[intersect( negs, (intersect(abovea,belowb)))]<-2
VidData$quad[intersect( negs, (intersect(belowa,belowb)))]<-3
###Create function that determines which quadrants have pesticide
for (i in 1:length(VidData$quad)){
r <- which(trayData$Repetition==VidData$rep[i])
t <- which(trayData$Trial==VidData$trial[i])
p <- which(trayData$Position==VidData$position[i])
id <- intersect( p, intersect(r, t))
VidData$DishID[i] <- trayData$DishID[id]
VidData$Orientation[i] <- trayData$Orientation[id]
#there has to be a better way to do this
one   <- c(1,2,3,4)
two   <- c(2,3,4,1)
three <- c(3,4,1,2)
four  <- c(4,1,2,3)
OTab  <- data.frame(one, two, three, four)
Or    <- which(OTab$one==VidData$Orientation[i])
VidData$PQuad[i] <- OTab[Or, VidData$Orientation[i]]
#I'm pretty sure the above 7 lines could be two.
}
uno<-which(VidData$PQuad==1)
dos<-which(VidData$PQuad==2)
tres<-which(VidData$PQuad==3)
cuatro<-which(VidData$PQuad==4)
VidData$Pesticide<-NA
VidData$Pesticide[uno]<-0
VidData$Pesticide[dos]<-1
VidData$Pesticide[tres]<-0
VidData$Pesticide[cuatro]<-1
return(VidData)
}
#=============
tryit<-Assign(VidData = DR1T1C2, CoordData = CoTbR1T1C2, trayData = TrayPlace)
View(tryit)
View(tryit)
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
Video FR1T1C1
Note that if X coords for TP and BP are exactly equal, it may create errors.
Tray<-c(1,2,3,4,5,6)
aMXL <-c(144,331,527,144,333,527)
aMXR <-c(331,527,728,333,527,728)
aMYT <-c(422,422,422,227,227,227)
aMYB <-c(227,227,227, 25, 25, 25)
aTPX <-c(248,,,,,)
aTPY <-c(404,,,,,)
aBPX <-c(246,,,,,)
aBPY <-c(245,,,,,)
aLPX <-c(167,,,,,)
aLPY <-c(327,,,,,)
aRPX <-c(,,,,,)
aRPY <-c(,,,,,)
#manually enter them in the dataframes below.
tester<-getpoint(FR1T1C1)
tester
?lines
imshow(FR1T1C2)
imshow(frame)
imshow(FR1T1C2)
lines(x = c(MXR[i], MXL[i]), y = c(MYT[i], MYB[i]))
imshow(FR1T1C2)
lines(x = c(FR1T1C2$MXR[i], FR1T1C2$MXL[i]), y = c(FR1T1C2$MYT[i], FR1T1C2$MYB[i]))
imshow(FR1T1C2)
lines(x = c(CoTbR1T1C2$MXR[i], CoTbR1T1C2$MXL[i]), y = c(CoTbR1T1C2$MYT[i], CoTbR1T1C2$MYB[i]))
imshow(FR1T1C2)
for(i in in 1:6){
lines(x = c(CoTbR1T1C2$MXR[i], CoTbR1T1C2$MXL[i]), y = c(CoTbR1T1C2$MYT[i], CoTbR1T1C2$MYB[i]))
}
imshow(FR1T1C2)
for(i in 1:6){
lines(x = c(CoTbR1T1C2$MXR[i], CoTbR1T1C2$MXL[i]), y = c(CoTbR1T1C2$MYT[i], CoTbR1T1C2$MYB[i]))
}
imshow(FR1T1C2)
for(i in 1:6){
lines(x = c(CoTbR1T1C2$MXR[i], CoTbR1T1C2$MXL[i]), y = c(CoTbR1T1C2$MYT[i], CoTbR1T1C2$MYT[i]))
lines(x = c(CoTbR1T1C2$MXR[i], CoTbR1T1C2$MXL[i]), y = c(CoTbR1T1C2$MYB[i], CoTbR1T1C2$MYB[i]))
}
imshow(FR1T1C2)
for(i in 1:6){
lines(x = c(CoTbR1T1C2$MXR[i], CoTbR1T1C2$MXL[i]), y = c(CoTbR1T1C2$MYT[i], CoTbR1T1C2$MYT[i]))
lines(x = c(CoTbR1T1C2$MXR[i], CoTbR1T1C2$MXL[i]), y = c(CoTbR1T1C2$MYB[i], CoTbR1T1C2$MYB[i]))
lines(x = c(CoTbR1T1C2$MXR[i], CoTbR1T1C2$MXR[i]), y = c(CoTbR1T1C2$MYT[i], CoTbR1T1C2$MYB[i]))
lines(x = c(CoTbR1T1C2$MXL[i], CoTbR1T1C2$MXL[i]), y = c(CoTbR1T1C2$MYT[i], CoTbR1T1C2$MYB[i]))
}
imshow(FR1T1C2)
for(i in 1:6){
lines(x = c(CoTbR1T1C2$MXR[i], CoTbR1T1C2$MXL[i]), y = c(CoTbR1T1C2$MYT[i], CoTbR1T1C2$MYT[i]))
lines(x = c(CoTbR1T1C2$MXR[i], CoTbR1T1C2$MXL[i]), y = c(CoTbR1T1C2$MYB[i], CoTbR1T1C2$MYB[i]))
lines(x = c(CoTbR1T1C2$MXR[i], CoTbR1T1C2$MXR[i]), y = c(CoTbR1T1C2$MYT[i], CoTbR1T1C2$MYB[i]))
lines(x = c(CoTbR1T1C2$MXL[i], CoTbR1T1C2$MXL[i]), y = c(CoTbR1T1C2$MYT[i], CoTbR1T1C2$MYB[i]))
lines(x = c(CoTbR1T1C2$TPX[i], CoTbR1T1C2$BPX[i]), y = c(CoTbR1T1C2$TPY[i], CoTbR1T1C2$BPY[i]))
lines(x = c(CoTbR1T1C2$LPX[i], CoTbR1T1C2$RPX[i]), y = c(CoTbR1T1C2$LPY[i], CoTbR1T1C2$RPY[i]))
}
visualize<-function(CD, frame){
imshow(frame)
for(i in in 1:6){
lines(x = c(CD$MXR[i], CD$MXL[i]), y = c(CD$MYT[i], CD$MYT[i]))
lines(x = c(CD$MXR[i], CD$MXL[i]), y = c(CD$MYB[i], CD$MYB[i]))
lines(x = c(CD$MXR[i], CD$MXR[i]), y = c(CD$MYT[i], CD$MYB[i]))
lines(x = c(CD$MXL[i], CD$MXL[i]), y = c(CD$MYT[i], CD$MYB[i]))
lines(x = c(CD$TPX[i], CD$BPX[i]), y = c(CD$TPY[i], CD$BPY[i]))
lines(x = c(CD$LPX[i], CD$RPX[i]), y = c(CD$LPY[i], CD$RPY[i]))
}
}
visualize<-function(CD, frame){
imshow(frame)
for(i in in 1:6){
lines(x = c(CD$MXR[i], CD$MXL[i]), y = c(CD$MYT[i], CD$MYT[i]))
lines(x = c(CD$MXR[i], CD$MXL[i]), y = c(CD$MYB[i], CD$MYB[i]))
lines(x = c(CD$MXR[i], CD$MXR[i]), y = c(CD$MYT[i], CD$MYB[i]))
lines(x = c(CD$MXL[i], CD$MXL[i]), y = c(CD$MYT[i], CD$MYB[i]))
lines(x = c(CD$TPX[i], CD$BPX[i]), y = c(CD$TPY[i], CD$BPY[i]))
lines(x = c(CD$LPX[i], CD$RPX[i]), y = c(CD$LPY[i], CD$RPY[i]))
}
}
visualize<-function(CD, frame){
imshow(frame)
for(i in 1:6){
lines(x = c(CD$MXR[i], CD$MXL[i]), y = c(CD$MYT[i], CD$MYT[i]))
lines(x = c(CD$MXR[i], CD$MXL[i]), y = c(CD$MYB[i], CD$MYB[i]))
lines(x = c(CD$MXR[i], CD$MXR[i]), y = c(CD$MYT[i], CD$MYB[i]))
lines(x = c(CD$MXL[i], CD$MXL[i]), y = c(CD$MYT[i], CD$MYB[i]))
lines(x = c(CD$TPX[i], CD$BPX[i]), y = c(CD$TPY[i], CD$BPY[i]))
lines(x = c(CD$LPX[i], CD$RPX[i]), y = c(CD$LPY[i], CD$RPY[i]))
}
}
visualize(FR1T1C2, CoTbR1T1C2)
visualize(frame = FR1T1C2, CD=CoTbR1T1C2)
x<-visualize(frame = FR1T1C2, CD=CoTbR1T1C2)
x
visualize(frame = FR1T1C2, CD=CoTbR1T1C2)
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
#manually enter them in the dataframes below.
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
tester<-getpoint(FR1T1C1)
tester
Video FR1T1C1
Note that if X coords for TP and BP are exactly equal, it may create errors.
Tray<-c(1,2,3,4,5,6)
aMXL <-c(144,331,527,144,333,527)
aMXR <-c(331,527,728,333,527,728)
aMYT <-c(422,422,422,227,227,227)
aMYB <-c(227,227,227, 25, 25, 25)
aTPX <-c(248,428,364,247,424,626)
aTPY <-c(404,395,390,210,207,194)
aBPX <-c(246,423,620,244,420,617)
aBPY <-c(245,231,232, 67, 65, 50)
aLPX <-c(167,341,547,162,347,550)
aLPY <-c(327,314,316,143,139,126)
aRPX <-c(322,509,709,319,503,697)
aRPY <-c(318,310,311,139,137,122)
#c(,,,,,)
#create a coordinate table
CoTbR1T1C1<-data.frame(Tray, aMXL, aMXR, aMYT, aMYB, aBPX, aBPY, aTPX, aTPY,
aRPX, aRPY, aLPX, aLPY)
#rename so that colums can be found in function
names(CoTbR1T1C1)<-c(Tray,MXL, MXR, MYT, MYB, BPX, BPY, TPX, TPY,
RPX, RPY, LPX, LPY)
write.csv(CoTbR1T1C1, CoTbR1T1C1.csv)
CoTbR1T1C1<-data.frame(Tray, aMXL, aMXR, aMYT, aMYB, aBPX, aBPY, aTPX, aTPY,
aRPX, aRPY, aLPX, aLPY)
#rename so that colums can be found in function
names(CoTbR1T1C1)<-c(Tray, MXL, MXR, MYT, MYB, BPX, BPY, TPX, TPY,
RPX, RPY, LPX, LPY)
write.csv(CoTbR1T1C1, "CoTbR1T1C1.csv")
CoTbR1T1C1
names(CoTbR1T1C1)<-c(Tray, "MXL", MXR, MYT, MYB, BPX, BPY, TPX, TPY,
RPX, RPY, LPX, LPY)
names(CoTbR1T1C1)<-c("Tray", "MXL", "MXR", "MYT", "MYB", "BPX", "BPY", "TPX", "TPY",
"RPX", "RPY", "LPX", "LPY")
CoTbR1T1C1
