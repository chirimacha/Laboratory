VidData$PQuad[i] <- OTab[Or, VidData$quad[i]]
#I'm pretty sure the above 7 lines could be two.
}
uno <- which(VidData$PQuad==1)
dos <- which(VidData$PQuad==2)
tres <- which(VidData$PQuad==3)
cuatro <- which(VidData$PQuad==4)
PTrays <- which(VidData$DishID <=6)
VidData$Pesticide<-NA
VidData$Pesticide[intersect( PTrays, uno)] <- 0
VidData$Pesticide[intersect( PTrays, dos)] <- 1
VidData$Pesticide[intersect( PTrays, tres)] <- 0
VidData$Pesticide[intersect( PTrays, cuatro)] <- 1
return(VidData)
}
View(DR2T1C1)
###Rep2
DR2T1C1 <- VidAnalysis(video=R2T1C1, bg= bgaRB, coordtab=CoTbR2T1C1, thresholda=50,
maxDistb=1000, cam=1, rep=2, trial=1)
write.csv(DR2T1C1, "Rep2Trial1Cam1RawData.csv")
DR2T1C2 <- VidAnalysis(video=R2T1C2, bg= bgbRB, coordtab=CoTbR2T1C2, thresholda=50,
maxDistb=1000, cam=2, rep=2, trial=1)
write.csv(DR2T1C2, "Rep2Trial1Cam2RawData.csv")
DR2T2C1 <- VidAnalysis(video=R2T2C1, bg= bgcRB, coordtab=CoTbR2T2C1, thresholda=50,
maxDistb=1000, cam=1, rep=2, trial=2)
write.csv(DR2T2C1, "Rep2Trial2Cam1RawData.csv")
DR2T2C2 <- VidAnalysis(video=R2T2C2, bg= bgdRB, coordtab=CoTbR2T2C2, thresholda=50,
maxDistb=1000, cam=2, rep=2, trial=2)
write.csv(DR2T2C2, "Rep2Trial2Cam2RawData.csv")
DR2T3C1 <- VidAnalysis(video=R2T3C1, bg= bgeRB, coordtab=CoTbR2T3C1, thresholda=50,
maxDistb=1000, cam=1, rep=2, trial=3)
write.csv(DR2T3C1, "Rep2Trial3Cam1RawData.csv")
DR2T3C2 <- VidAnalysis(video=R2T3C2, bg= bgfRB, coordtab=CoTbR2T3C2, thresholda=50,
maxDistb=1000, cam=2, rep=2, trial=3)
write.csv(DR2T3C2, "Rep2Trial3Cam2RawData.csv")
View(CoTbR1T1C2)
VidAnalysis<-function(video, bg, coordtab, thresholda, maxDistb, cam, rep, trial){
#create the background
#bg <- backgrounder(video, n = 1800, method = "mean", color = FALSE)
#create black masks to isolate each petridish using matrix
mat1 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat2 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat3 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat4 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat5 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat6 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
#create whole for each petridish in each mask
#sadly, for each dish we need to define the area by hand.
#mat works left to right, but top to bottom.
#Graphing works bottom to top so we need correction
mat1[((bg$dim[1])-coordtab$MYT[1]):((bg$dim[1])-coordtab$MYB[1]),
coordtab$MXL[1]:coordtab$MXR[1]] <- 1
mat2[((bg$dim[1])-coordtab$MYT[2]):((bg$dim[1])-coordtab$MYB[2]),
coordtab$MXL[2]:coordtab$MXR[2]] <- 1
mat3[((bg$dim[1])-coordtab$MYT[3]):((bg$dim[1])-coordtab$MYB[3]),
coordtab$MXL[3]:coordtab$MXR[3]] <- 1
mat4[((bg$dim[1])-coordtab$MYT[4]):((bg$dim[1])-coordtab$MYB[4]),
coordtab$MXL[4]:coordtab$MXR[4]] <- 1
mat5[((bg$dim[1])-coordtab$MYT[5]):((bg$dim[1])-coordtab$MYB[5]),
coordtab$MXL[5]:coordtab$MXR[5]] <- 1
mat6[((bg$dim[1])-coordtab$MYT[6]):((bg$dim[1])-coordtab$MYB[6]),
coordtab$MXL[6]:coordtab$MXR[6]] <- 1
#Make Mask Matrix into an image
pmaska <- (r2img(mat1))
pmaskb <- (r2img(mat2))
pmaskc <- (r2img(mat3))
pmaskd <- (r2img(mat4))
pmaske <- (r2img(mat5))
pmaskf <- (r2img(mat6))
#now bring the mask and the background together
nbga1<-blend(bg, pmaska, "*")
nbga2<-blend(bg, pmaskb, "*")
nbga3<-blend(bg, pmaskc, "*")
nbga4<-blend(bg, pmaskd, "*")
nbga5<-blend(bg, pmaske, "*")
nbga6<-blend(bg, pmaskf, "*")
#Create Function that finds the coordinate of the insect in each quadrant in each frame
Coords<-function(video, pmask, nbga, coordtaba, tn, threshold, maxDista, rep, cam){
#determine loop length
#     if (video$length<1800) {
#       fr <- video$length
#     } else {
#       fr<-1800
#     }
#temporarily set fr to 20 to speed up code while debugging.
fr<-20
#Reset bugpos to blank data frame
bugpos<-data.frame()
for (i in 1:fr){
#extract individual frames
res<-getFrame(video, i)
#put frame into grey scale.
gryscl <- ddd2d(res)
#mask other petri dishes
mask<-blend(gryscl, pmask, "*")
#subtract background from the mask. Only movement will show
sub<-blend(nbga, mask, "-")
#set a threshold difference to remove changes due to glare/reflection/noise
bw<-thresholding(sub, threshold, "binary")
#detect the white blobs that are created. Get coordinates
bugcords<-blobDetector(bw)
# add track # to data frame only if a change is detected
if(nrow(bugcords)>0) {
bugcords<-mutate(bugcords, frame = i, track = NA)
#determines what points are linked. Optimally each insect given 1 track each
#because there is only one object, we can max out maxDist.
stout<-simpleTracker(past = bugpos, current = bugcords, maxDist = maxDista)
#combine tables previous in the loop.
bugpos<- rbind(bugpos, stout)
}
}
ya<-c(coordtaba$BPY[tn],coordtaba$TPY[tn])
xa<-c(coordtaba$BPX[tn],coordtaba$TPX[tn])
# #In the future I will need to do the same thing in x chord.
yb<-c(coordtaba$LPY[tn],coordtab$RPY[tn]) #96
xb<-c(coordtaba$LPX[tn],coordtab$RPX[tn])
#generate line equation
line1a<-lm(ya~xa)
line1b<-lm(yb~xb)
#obtain data for prediction
newsa<-data.frame(xa = bugpos$x)
newsb<-data.frame(xb = bugpos$x)
#predict the location of line at specified location
bugpos$pred1 <- predict(line1a, newsa, na.rm=TRUE)
bugpos$pred2 <- predict(line1b, newsb, na.rm=TRUE)
bugpos$TPX<-coordtaba$TPX[tn]
bugpos$TPY<-coordtaba$TPX[tn]
#     #determine if bug is above or below line (differnet from predicted y)
#     belowa<-which((bugpos$y) <  (bugpos$pred1))
#     abovea<-which((bugpos$y) >= (bugpos$pred1))
#     belowb<-which((bugpos$y) <  (bugpos$pred2))
#     aboveb<-which((bugpos$y) >= (bugpos$pred2))
#     which()
# # Determine Quadrants #change depending on slope of verticle line
#     if((coordtab$TPX[tn]) > (coordtab$BPX[tn])) {
#       bugpos$quad[intersect(belowa,aboveb)]<-1
#       bugpos$quad[intersect(abovea,aboveb)]<-4
#       bugpos$quad[intersect(belowa,belowb)]<-2
#       bugpos$quad[intersect(abovea,belowb)]<-3
#     } else {
#       bugpos$quad[intersect(abovea,aboveb)]<-1
#       bugpos$quad[intersect(belowa,aboveb)]<-4
#       bugpos$quad[intersect(abovea,belowb)]<-2
#       bugpos$quad[intersect(belowa,belowb)]<-3
#     }
#indicate the tray in data table.
bugpos$trayn<-tn
#return the data table.
return(bugpos)
}
#Now run this subfunction over the 6 dishes
pdt1 <-Coords(video, pmaska, nbga1, coordtaba=coordtab, tn=1,
threshold=thresholda, maxDista=maxDistb)
pdt2 <-Coords(video, pmaskb, nbga2, coordtaba=coordtab, tn=2,
threshold=thresholda, maxDista=maxDistb)
pdt3 <-Coords(video, pmaskc, nbga3, coordtaba=coordtab, tn=3,
threshold=thresholda, maxDista=maxDistb)
pdt4 <-Coords(video, pmaskd, nbga4, coordtaba=coordtab, tn=4,
threshold=thresholda, maxDista=maxDistb)
pdt5 <-Coords(video, pmaske, nbga5, coordtaba=coordtab, tn=5,
threshold=thresholda, maxDista=maxDistb)
pdt6 <-Coords(video, pmaskf, nbga6, coordtaba=coordtab, tn=6,
threshold=thresholda, maxDista=maxDistb)
#Bind All the tables
MasterTab<-rbind(pdt1, pdt2, pdt3, pdt4, pdt5, pdt6)
#indicate which camera this is
MasterTab$camera<-cam
#Indicate which repetition
MasterTab$rep<-rep
MasterTab$trial<-trial
MasterTab$position<-(MasterTab$trayn)+(6*(cam-1))
#Output as single data table
return(MasterTab)
}
DR1T1C1 <- VidAnalysis(video=R1T1C1, bg= bga, coordtab=CoTbR1T1C1, thresholda=50,
maxDistb=1000, cam=1, rep=1, trial=1)
DR2T1C1 <- VidAnalysis(video=R2T1C1, bg= bgaRB, coordtab=CoTbR2T1C1, thresholda=50,
maxDistb=1000, cam=1, rep=2, trial=1)
write.csv(DR2T1C1, "Rep2Trial1Cam1RawData.csv")
View(DR1T1C1)
View(DR2T1C1)
VidAnalysis<-function(video, bg, coordtab, thresholda, maxDistb, cam, rep, trial){
#create the background
#bg <- backgrounder(video, n = 1800, method = "mean", color = FALSE)
#create black masks to isolate each petridish using matrix
mat1 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat2 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat3 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat4 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat5 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat6 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
#create whole for each petridish in each mask
#sadly, for each dish we need to define the area by hand.
#mat works left to right, but top to bottom.
#Graphing works bottom to top so we need correction
mat1[((bg$dim[1])-coordtab$MYT[1]):((bg$dim[1])-coordtab$MYB[1]),
coordtab$MXL[1]:coordtab$MXR[1]] <- 1
mat2[((bg$dim[1])-coordtab$MYT[2]):((bg$dim[1])-coordtab$MYB[2]),
coordtab$MXL[2]:coordtab$MXR[2]] <- 1
mat3[((bg$dim[1])-coordtab$MYT[3]):((bg$dim[1])-coordtab$MYB[3]),
coordtab$MXL[3]:coordtab$MXR[3]] <- 1
mat4[((bg$dim[1])-coordtab$MYT[4]):((bg$dim[1])-coordtab$MYB[4]),
coordtab$MXL[4]:coordtab$MXR[4]] <- 1
mat5[((bg$dim[1])-coordtab$MYT[5]):((bg$dim[1])-coordtab$MYB[5]),
coordtab$MXL[5]:coordtab$MXR[5]] <- 1
mat6[((bg$dim[1])-coordtab$MYT[6]):((bg$dim[1])-coordtab$MYB[6]),
coordtab$MXL[6]:coordtab$MXR[6]] <- 1
#Make Mask Matrix into an image
pmaska <- (r2img(mat1))
pmaskb <- (r2img(mat2))
pmaskc <- (r2img(mat3))
pmaskd <- (r2img(mat4))
pmaske <- (r2img(mat5))
pmaskf <- (r2img(mat6))
#now bring the mask and the background together
nbga1<-blend(bg, pmaska, "*")
nbga2<-blend(bg, pmaskb, "*")
nbga3<-blend(bg, pmaskc, "*")
nbga4<-blend(bg, pmaskd, "*")
nbga5<-blend(bg, pmaske, "*")
nbga6<-blend(bg, pmaskf, "*")
#Create Function that finds the coordinate of the insect in each quadrant in each frame
Coords<-function(video, pmask, nbga, coordtaba, tn, threshold, maxDista, rep, cam){
#determine loop length
#     if (video$length<1800) {
#       fr <- video$length
#     } else {
#       fr<-1800
#     }
#temporarily set fr to 20 to speed up code while debugging.
fr<-20
#Reset bugpos to blank data frame
bugpos<-data.frame()
for (i in 1:fr){
#extract individual frames
res<-getFrame(video, i)
#put frame into grey scale.
gryscl <- ddd2d(res)
#mask other petri dishes
mask<-blend(gryscl, pmask, "*")
#subtract background from the mask. Only movement will show
sub<-blend(nbga, mask, "-")
#set a threshold difference to remove changes due to glare/reflection/noise
bw<-thresholding(sub, threshold, "binary")
#detect the white blobs that are created. Get coordinates
bugcords<-blobDetector(bw)
# add track # to data frame only if a change is detected
if(nrow(bugcords)>0) {
bugcords<-mutate(bugcords, frame = i, track = NA)
#determines what points are linked. Optimally each insect given 1 track each
#because there is only one object, we can max out maxDist.
stout<-simpleTracker(past = bugpos, current = bugcords, maxDist = maxDista)
#combine tables previous in the loop.
bugpos<- rbind(bugpos, stout)
}
}
ya<-c(coordtaba$BPY[tn],coordtaba$TPY[tn])
xa<-c(coordtaba$BPX[tn],coordtaba$TPX[tn])
# #In the future I will need to do the same thing in x chord.
yb<-c(coordtaba$LPY[tn],coordtab$RPY[tn]) #96
xb<-c(coordtaba$LPX[tn],coordtab$RPX[tn])
#generate line equation
line1a<-lm(ya~xa)
line1b<-lm(yb~xb)
#obtain data for prediction
newsa<-data.frame(xa = bugpos$x)
newsb<-data.frame(xb = bugpos$x)
#predict the location of line at specified location
bugpos$pred1 <- predict(line1a, newsa, na.rm=TRUE)
bugpos$pred2 <- predict(line1b, newsb, na.rm=TRUE)
bugpos$TPX<-coordtaba$TPX[tn]
bugpos$TBY<-coordtaba$TBX[tn]
#     #determine if bug is above or below line (differnet from predicted y)
#     belowa<-which((bugpos$y) <  (bugpos$pred1))
#     abovea<-which((bugpos$y) >= (bugpos$pred1))
#     belowb<-which((bugpos$y) <  (bugpos$pred2))
#     aboveb<-which((bugpos$y) >= (bugpos$pred2))
#     which()
# # Determine Quadrants #change depending on slope of verticle line
#     if((coordtab$TPX[tn]) > (coordtab$BPX[tn])) {
#       bugpos$quad[intersect(belowa,aboveb)]<-1
#       bugpos$quad[intersect(abovea,aboveb)]<-4
#       bugpos$quad[intersect(belowa,belowb)]<-2
#       bugpos$quad[intersect(abovea,belowb)]<-3
#     } else {
#       bugpos$quad[intersect(abovea,aboveb)]<-1
#       bugpos$quad[intersect(belowa,aboveb)]<-4
#       bugpos$quad[intersect(abovea,belowb)]<-2
#       bugpos$quad[intersect(belowa,belowb)]<-3
#     }
#indicate the tray in data table.
bugpos$trayn<-tn
#return the data table.
return(bugpos)
}
#Now run this subfunction over the 6 dishes
pdt1 <-Coords(video, pmaska, nbga1, coordtaba=coordtab, tn=1,
threshold=thresholda, maxDista=maxDistb)
pdt2 <-Coords(video, pmaskb, nbga2, coordtaba=coordtab, tn=2,
threshold=thresholda, maxDista=maxDistb)
pdt3 <-Coords(video, pmaskc, nbga3, coordtaba=coordtab, tn=3,
threshold=thresholda, maxDista=maxDistb)
pdt4 <-Coords(video, pmaskd, nbga4, coordtaba=coordtab, tn=4,
threshold=thresholda, maxDista=maxDistb)
pdt5 <-Coords(video, pmaske, nbga5, coordtaba=coordtab, tn=5,
threshold=thresholda, maxDista=maxDistb)
pdt6 <-Coords(video, pmaskf, nbga6, coordtaba=coordtab, tn=6,
threshold=thresholda, maxDista=maxDistb)
#Bind All the tables
MasterTab<-rbind(pdt1, pdt2, pdt3, pdt4, pdt5, pdt6)
#indicate which camera this is
MasterTab$camera<-cam
#Indicate which repetition
MasterTab$rep<-rep
MasterTab$trial<-trial
MasterTab$position<-(MasterTab$trayn)+(6*(cam-1))
#Output as single data table
return(MasterTab)
}
DR2T1C1 <- VidAnalysis(video=R2T1C1, bg= bgaRB, coordtab=CoTbR2T1C1, thresholda=50,
maxDistb=1000, cam=1, rep=2, trial=1)
write.csv(DR2T1C1, "Rep2Trial1Cam1RawData.csv")
View(DR2T1C1)
VidAnalysis<-function(video, bg, coordtab, thresholda, maxDistb, cam, rep, trial){
#create the background
#bg <- backgrounder(video, n = 1800, method = "mean", color = FALSE)
#create black masks to isolate each petridish using matrix
mat1 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat2 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat3 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat4 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat5 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat6 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
#create whole for each petridish in each mask
#sadly, for each dish we need to define the area by hand.
#mat works left to right, but top to bottom.
#Graphing works bottom to top so we need correction
mat1[((bg$dim[1])-coordtab$MYT[1]):((bg$dim[1])-coordtab$MYB[1]),
coordtab$MXL[1]:coordtab$MXR[1]] <- 1
mat2[((bg$dim[1])-coordtab$MYT[2]):((bg$dim[1])-coordtab$MYB[2]),
coordtab$MXL[2]:coordtab$MXR[2]] <- 1
mat3[((bg$dim[1])-coordtab$MYT[3]):((bg$dim[1])-coordtab$MYB[3]),
coordtab$MXL[3]:coordtab$MXR[3]] <- 1
mat4[((bg$dim[1])-coordtab$MYT[4]):((bg$dim[1])-coordtab$MYB[4]),
coordtab$MXL[4]:coordtab$MXR[4]] <- 1
mat5[((bg$dim[1])-coordtab$MYT[5]):((bg$dim[1])-coordtab$MYB[5]),
coordtab$MXL[5]:coordtab$MXR[5]] <- 1
mat6[((bg$dim[1])-coordtab$MYT[6]):((bg$dim[1])-coordtab$MYB[6]),
coordtab$MXL[6]:coordtab$MXR[6]] <- 1
#Make Mask Matrix into an image
pmaska <- (r2img(mat1))
pmaskb <- (r2img(mat2))
pmaskc <- (r2img(mat3))
pmaskd <- (r2img(mat4))
pmaske <- (r2img(mat5))
pmaskf <- (r2img(mat6))
#now bring the mask and the background together
nbga1<-blend(bg, pmaska, "*")
nbga2<-blend(bg, pmaskb, "*")
nbga3<-blend(bg, pmaskc, "*")
nbga4<-blend(bg, pmaskd, "*")
nbga5<-blend(bg, pmaske, "*")
nbga6<-blend(bg, pmaskf, "*")
#Create Function that finds the coordinate of the insect in each quadrant in each frame
Coords<-function(video, pmask, nbga, coordtaba, tn, threshold, maxDista, rep, cam){
#determine loop length
#     if (video$length<1800) {
#       fr <- video$length
#     } else {
#       fr<-1800
#     }
#temporarily set fr to 20 to speed up code while debugging.
fr<-20
#Reset bugpos to blank data frame
bugpos<-data.frame()
for (i in 1:fr){
#extract individual frames
res<-getFrame(video, i)
#put frame into grey scale.
gryscl <- ddd2d(res)
#mask other petri dishes
mask<-blend(gryscl, pmask, "*")
#subtract background from the mask. Only movement will show
sub<-blend(nbga, mask, "-")
#set a threshold difference to remove changes due to glare/reflection/noise
bw<-thresholding(sub, threshold, "binary")
#detect the white blobs that are created. Get coordinates
bugcords<-blobDetector(bw)
# add track # to data frame only if a change is detected
if(nrow(bugcords)>0) {
bugcords<-mutate(bugcords, frame = i, track = NA)
#determines what points are linked. Optimally each insect given 1 track each
#because there is only one object, we can max out maxDist.
stout<-simpleTracker(past = bugpos, current = bugcords, maxDist = maxDista)
#combine tables previous in the loop.
bugpos<- rbind(bugpos, stout)
}
}
ya<-c(coordtaba$BPY[tn],coordtaba$TPY[tn])
xa<-c(coordtaba$BPX[tn],coordtaba$TPX[tn])
# #In the future I will need to do the same thing in x chord.
yb<-c(coordtaba$LPY[tn],coordtab$RPY[tn]) #96
xb<-c(coordtaba$LPX[tn],coordtab$RPX[tn])
#generate line equation
line1a<-lm(ya~xa)
line1b<-lm(yb~xb)
#obtain data for prediction
newsa<-data.frame(xa = bugpos$x)
newsb<-data.frame(xb = bugpos$x)
#predict the location of line at specified location
bugpos$pred1 <- predict(line1a, newsa, na.rm=TRUE)
bugpos$pred2 <- predict(line1b, newsb, na.rm=TRUE)
bugpos$TPX<-coordtaba$TPX[tn]
bugpos$BPX<-coordtaba$BPX[tn]
#     #determine if bug is above or below line (differnet from predicted y)
#     belowa<-which((bugpos$y) <  (bugpos$pred1))
#     abovea<-which((bugpos$y) >= (bugpos$pred1))
#     belowb<-which((bugpos$y) <  (bugpos$pred2))
#     aboveb<-which((bugpos$y) >= (bugpos$pred2))
#     which()
# # Determine Quadrants #change depending on slope of verticle line
#     if((coordtab$TPX[tn]) > (coordtab$BPX[tn])) {
#       bugpos$quad[intersect(belowa,aboveb)]<-1
#       bugpos$quad[intersect(abovea,aboveb)]<-4
#       bugpos$quad[intersect(belowa,belowb)]<-2
#       bugpos$quad[intersect(abovea,belowb)]<-3
#     } else {
#       bugpos$quad[intersect(abovea,aboveb)]<-1
#       bugpos$quad[intersect(belowa,aboveb)]<-4
#       bugpos$quad[intersect(abovea,belowb)]<-2
#       bugpos$quad[intersect(belowa,belowb)]<-3
#     }
#indicate the tray in data table.
bugpos$trayn<-tn
#return the data table.
return(bugpos)
}
#Now run this subfunction over the 6 dishes
pdt1 <-Coords(video, pmaska, nbga1, coordtaba=coordtab, tn=1,
threshold=thresholda, maxDista=maxDistb)
pdt2 <-Coords(video, pmaskb, nbga2, coordtaba=coordtab, tn=2,
threshold=thresholda, maxDista=maxDistb)
pdt3 <-Coords(video, pmaskc, nbga3, coordtaba=coordtab, tn=3,
threshold=thresholda, maxDista=maxDistb)
pdt4 <-Coords(video, pmaskd, nbga4, coordtaba=coordtab, tn=4,
threshold=thresholda, maxDista=maxDistb)
pdt5 <-Coords(video, pmaske, nbga5, coordtaba=coordtab, tn=5,
threshold=thresholda, maxDista=maxDistb)
pdt6 <-Coords(video, pmaskf, nbga6, coordtaba=coordtab, tn=6,
threshold=thresholda, maxDista=maxDistb)
#Bind All the tables
MasterTab<-rbind(pdt1, pdt2, pdt3, pdt4, pdt5, pdt6)
#indicate which camera this is
MasterTab$camera<-cam
#Indicate which repetition
MasterTab$rep<-rep
MasterTab$trial<-trial
MasterTab$position<-(MasterTab$trayn)+(6*(cam-1))
#Output as single data table
return(MasterTab)
}
DR2T1C1 <- VidAnalysis(video=R2T1C1, bg= bgaRB, coordtab=CoTbR2T1C1, thresholda=50,
maxDistb=1000, cam=1, rep=2, trial=1)
View(DR2T1C1)
belowa <- which((CompVidRep2$y) <  (CompVidRep2$pred1))
abovea <- which((CompVidRep2$y) >= (CompVidRep2$pred1))
belowb <- which((CompVidRep2$y) <  (CompVidRep2$pred2))
aboveb <- which((CompVidRep2$y) >= (CompVidRep2$pred2))
NegSlope <- which(CompVidRep2$TPX <  CompVidRep2$BPX )
PosSlope <- which(CompVidRep2$TPX >= CompVidRep2$BPX )
# Determine Quadrants #change depending on slope of verticle line
# In cases of positive slopes
CompVidRep2$quad<-NA
CompVidRep2$quad[intersect( PosSlope, (intersect(belowa,aboveb)))]<-1
CompVidRep2$quad[intersect( PosSlope, (intersect(abovea,aboveb)))]<-4
CompVidRep2$quad[intersect( PosSlope, (intersect(belowa,belowb)))]<-2
CompVidRep2$quad[intersect( PosSlope, (intersect(abovea,belowb)))]<-3
CompVidRep2$quad[intersect( NegSlope, (intersect(abovea,aboveb)))]<-1
CompVidRep2$quad[intersect( NegSlope, (intersect(belowa,aboveb)))]<-4
CompVidRep2$quad[intersect( NegSlope, (intersect(abovea,belowb)))]<-2
CompVidRep2$quad[intersect( NegSlope, (intersect(belowa,belowb)))]<-3
###Create function that determines which quadrants have pesticide
for (i in 1:length(CompVidRep2$quad)) {
r <- which(TrayPlace$Repetition==CompVidRep2$rep[i])
t <- which(TrayPlace$Trial==CompVidRep2$trial[i])
p <- which(TrayPlace$Position==CompVidRep2$position[i])
id <- intersect( p, intersect(r, t))
CompVidRep2$DishID[i] <- TrayPlace$DishID[id]
CompVidRep2$Orientation[i] <- TrayPlace$Orientation[id]
#there has to be a better way to do this
one   <- c(1,2,3,4)
two   <- c(2,3,4,1)
three <- c(3,4,1,2)
four  <- c(4,1,2,3)
OTab  <- data.frame(one, two, three, four)
Or    <- which(OTab$one==CompVidRep2$Orientation[i])
CompVidRep2$PQuad[i] <- OTab[Or, CompVidRep2$Orientation[i]]
#I'm pretty sure the above 7 lines could be two.
}
uno <- which(CompVidRep2$PQuad==1)
dos <- which(CompVidRep2$PQuad==2)
tres <- which(CompVidRep2$PQuad==3)
cuatro <- which(CompVidRep2$PQuad==4)
PTrays<- which(CompVidRep2$DishID <=6)
CompVidRep2$Pesticide <- NA
CompVidRep2$Pesticide[uno] <- 0
CompVidRep2$Pesticide[intersect( PTrays, dos)] <- 1
CompVidRep2$Pesticide[tres] <- 0
CompVidRep2$Pesticide[intersect( PTrays, cuatro)] <- 1
View(CompVidRep2)
visualize(frame = FR2T1C1, CD=CoTbR2T1C1)
View(TrayPlace)
