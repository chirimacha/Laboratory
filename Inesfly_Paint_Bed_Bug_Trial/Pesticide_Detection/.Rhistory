#     belowa<-which((bugpos$y) <  (bugpos$pred1))
#     abovea<-which((bugpos$y) >= (bugpos$pred1))
#     belowb<-which((bugpos$y) <  (bugpos$pred2))
#     aboveb<-which((bugpos$y) >= (bugpos$pred2))
#     which()
# # Determine Quadrants #change depending on slope of verticle line
#     if((coordtab$TPX[tn]) > (coordtab$BPX[tn])) {
#       bugpos$quad[intersect(belowa,aboveb)]<-1
#       bugpos$quad[intersect(abovea,aboveb)]<-4
#       bugpos$quad[intersect(belowa,belowb)]<-2
#       bugpos$quad[intersect(abovea,belowb)]<-3
#     } else {
#       bugpos$quad[intersect(abovea,aboveb)]<-1
#       bugpos$quad[intersect(belowa,aboveb)]<-4
#       bugpos$quad[intersect(abovea,belowb)]<-2
#       bugpos$quad[intersect(belowa,belowb)]<-3
#     }
#indicate the tray in data table.
bugpos$trayn<-tn
#return the data table.
return(bugpos)
}
#Now run this subfunction over the 6 dishes
pdt1 <-Coords(video, pmaska, nbga1, coordtaba=coordtab, tn=1,
threshold=thresholda, maxDista=maxDistb)
pdt2 <-Coords(video, pmaskb, nbga2, coordtaba=coordtab, tn=2,
threshold=thresholda, maxDista=maxDistb)
pdt3 <-Coords(video, pmaskc, nbga3, coordtaba=coordtab, tn=3,
threshold=thresholda, maxDista=maxDistb)
pdt4 <-Coords(video, pmaskd, nbga4, coordtaba=coordtab, tn=4,
threshold=thresholda, maxDista=maxDistb)
pdt5 <-Coords(video, pmaske, nbga5, coordtaba=coordtab, tn=5,
threshold=thresholda, maxDista=maxDistb)
pdt6 <-Coords(video, pmaskf, nbga6, coordtaba=coordtab, tn=6,
threshold=thresholda, maxDista=maxDistb)
#Bind All the tables
MasterTab<-rbind(pdt1, pdt2, pdt3, pdt4, pdt5, pdt6)
#indicate which camera this is
MasterTab$camera<-cam
#Indicate which repetition
MasterTab$rep<-rep
MasterTab$trial<-trial
MasterTab$position<-(MasterTab$trayn)+(6*(cam-1))
#Output as single data table
return(MasterTab)
}
###############################################################################
#run
#DR1T1C1<-VidAnalysis(video=R1T1C2, coordtab=CoTbR1T1C1, thresholda=50,
#              maxDistb=1000)
DR1T1C2<-VidAnalysis(video=R1T1C2, coordtab=CoTbR1T1C2, thresholda=50,
maxDistb=1000, cam=2, rep=1, trial=1)
VidAnalysis<-function(video, coordtab, thresholda, maxDistb, cam, rep, trial){
#create the background
#bg <- backgrounder(video, n = 1800, method = "mean", color = FALSE)
#create black masks to isolate each petridish using matrix
mat1 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat2 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat3 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat4 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat5 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat6 <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
#create whole for each petridish in each mask
#sadly, for each dish we need to define the area by hand.
#mat works left to right, but top to bottom.
#Graphing works bottom to top so we need correction
mat1[((bg$dim[1])-coordtab$MYT[1]):((bg$dim[1])-coordtab$MYB[1]),
coordtab$MXL[1]:coordtab$MXR[1]] <- 1
mat2[((bg$dim[1])-coordtab$MYT[2]):((bg$dim[1])-coordtab$MYB[2]),
coordtab$MXL[2]:coordtab$MXR[2]] <- 1
mat3[((bg$dim[1])-coordtab$MYT[3]):((bg$dim[1])-coordtab$MYB[3]),
coordtab$MXL[3]:coordtab$MXR[3]] <- 1
mat4[((bg$dim[1])-coordtab$MYT[4]):((bg$dim[1])-coordtab$MYB[4]),
coordtab$MXL[4]:coordtab$MXR[4]] <- 1
mat5[((bg$dim[1])-coordtab$MYT[5]):((bg$dim[1])-coordtab$MYB[5]),
coordtab$MXL[5]:coordtab$MXR[5]] <- 1
mat6[((bg$dim[1])-coordtab$MYT[6]):((bg$dim[1])-coordtab$MYB[6]),
coordtab$MXL[6]:coordtab$MXR[6]] <- 1
#Make Mask Matrix into an image
pmaska <- (r2img(mat1))
pmaskb <- (r2img(mat2))
pmaskc <- (r2img(mat3))
pmaskd <- (r2img(mat4))
pmaske <- (r2img(mat5))
pmaskf <- (r2img(mat6))
#now bring the mask and the background together
nbga1<-blend(bg, pmaska, "*")
nbga2<-blend(bg, pmaskb, "*")
nbga3<-blend(bg, pmaskc, "*")
nbga4<-blend(bg, pmaskd, "*")
nbga5<-blend(bg, pmaske, "*")
nbga6<-blend(bg, pmaskf, "*")
#Create Function that finds the coordinate of the insect in each quadrant in each frame
Coords<-function(video, pmask, nbga, coordtaba, tn, threshold, maxDista, rep, cam){
#determine loop length
#     if (video$length<1800) {
#       fr <- video$length
#     } else {
#       fr<-1800
#     }
#temporarily set fr to 20 to speed up code while debugging.
fr<-20
#Reset bugpos to blank data frame
bugpos<-data.frame()
for (i in 1:fr){
#extract individual frames
res<-getFrame(video, i)
#put frame into grey scale.
gryscl <- ddd2d(res)
#mask other petri dishes
mask<-blend(gryscl, pmask, "*")
#subtract background from the mask. Only movement will show
sub<-blend(nbga, mask, "-")
#set a threshold difference to remove changes due to glare/reflection/noise
bw<-thresholding(sub, threshold, "binary")
#detect the white blobs that are created. Get coordinates
bugcords<-blobDetector(bw)
# add track # to data frame only if a change is detected
if(nrow(bugcords)>0) {
bugcords<-mutate(bugcords, frame = i, track = NA)
#determines what points are linked. Optimally each insect given 1 track each
#because there is only one object, we can max out maxDist.
stout<-simpleTracker(past = bugpos, current = bugcords, maxDist = maxDista)
#combine tables previous in the loop.
bugpos<- rbind(bugpos, stout)
}
}
ya<-c(coordtaba$BPY[tn],coordtaba$TPY[tn])
xa<-c(coordtaba$BPX[tn],coordtaba$TPX[tn])
# #In the future I will need to do the same thing in x chord.
yb<-c(coordtaba$LPY[tn],coordtab$RPY[tn]) #96
xb<-c(coordtaba$LPX[tn],coordtab$RPX[tn])
#generate line equation
line1a<-lm(ya~xa)
line1b<-lm(yb~xb)
#obtain data for prediction
newsa<-data.frame(xa = bugpos$x)
newsb<-data.frame(xb = bugpos$x)
#predict the location of line at specified location
bugpos$pred1 <- predict(line1a, newsa, na.rm=TRUE)
bugpos$pred2 <- predict(line1b, newsb, na.rm=TRUE)
#     #determine if bug is above or below line (differnet from predicted y)
#     belowa<-which((bugpos$y) <  (bugpos$pred1))
#     abovea<-which((bugpos$y) >= (bugpos$pred1))
#     belowb<-which((bugpos$y) <  (bugpos$pred2))
#     aboveb<-which((bugpos$y) >= (bugpos$pred2))
#     which()
# # Determine Quadrants #change depending on slope of verticle line
#     if((coordtab$TPX[tn]) > (coordtab$BPX[tn])) {
#       bugpos$quad[intersect(belowa,aboveb)]<-1
#       bugpos$quad[intersect(abovea,aboveb)]<-4
#       bugpos$quad[intersect(belowa,belowb)]<-2
#       bugpos$quad[intersect(abovea,belowb)]<-3
#     } else {
#       bugpos$quad[intersect(abovea,aboveb)]<-1
#       bugpos$quad[intersect(belowa,aboveb)]<-4
#       bugpos$quad[intersect(abovea,belowb)]<-2
#       bugpos$quad[intersect(belowa,belowb)]<-3
#     }
#indicate the tray in data table.
bugpos$trayn<-tn
#return the data table.
return(bugpos)
}
#Now run this subfunction over the 6 dishes
pdt1 <-Coords(video, pmaska, nbga1, coordtaba=coordtab, tn=1,
threshold=thresholda, maxDista=maxDistb)
pdt2 <-Coords(video, pmaskb, nbga2, coordtaba=coordtab, tn=2,
threshold=thresholda, maxDista=maxDistb)
pdt3 <-Coords(video, pmaskc, nbga3, coordtaba=coordtab, tn=3,
threshold=thresholda, maxDista=maxDistb)
pdt4 <-Coords(video, pmaskd, nbga4, coordtaba=coordtab, tn=4,
threshold=thresholda, maxDista=maxDistb)
pdt5 <-Coords(video, pmaske, nbga5, coordtaba=coordtab, tn=5,
threshold=thresholda, maxDista=maxDistb)
pdt6 <-Coords(video, pmaskf, nbga6, coordtaba=coordtab, tn=6,
threshold=thresholda, maxDista=maxDistb)
#Bind All the tables
MasterTab<-rbind(pdt1, pdt2, pdt3, pdt4, pdt5, pdt6)
#indicate which camera this is
MasterTab$camera<-cam
#Indicate which repetition
MasterTab$rep<-rep
MasterTab$trial<-trial
MasterTab$position<-(MasterTab$trayn)+(6*(cam-1))
#Output as single data table
return(MasterTab)
}
###############################################################################
#run
#DR1T1C1<-VidAnalysis(video=R1T1C2, coordtab=CoTbR1T1C1, thresholda=50,
#              maxDistb=1000)
DR1T1C2<-VidAnalysis(video=R1T1C2, coordtab=CoTbR1T1C2, thresholda=50,
maxDistb=1000, cam=2, rep=1, trial=1)
belowa <- which((DR1T1C2$y) <  (DR1T1C2$pred1))
abovea <- which((DR1T1C2$y) >= (DR1T1C2$pred1))
belowb <- which((DR1T1C2$y) <  (DR1T1C2$pred2))
aboveb <- which((DR1T1C2$y) >= (DR1T1C2$pred2))
NegSlope <- which(CoTbR1T1C2$TPX <  CoTbR1T1C2$BPX )
PosSlope <- which(CoTbR1T1C2$TPX >= CoTbR1T1C2$BPX )
negs<-which(is.na(match(DR1T1C2$trayn, NegSlope))==FALSE)
poss<-which(is.na(match(DR1T1C2$trayn, PosSlope))==FALSE)
# Determine Quadrants #change depending on slope of verticle line
# In cases of positive slopes
DR1T1C2$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
DR1T1C2$quad[intersect( poss, (intersect(abovea,aboveb)))]<-4
DR1T1C2$quad[intersect( poss, (intersect(belowa,belowb)))]<-2
DR1T1C2$quad[intersect( poss, (intersect(abovea,belowb)))]<-3
DR1T1C2$quad[intersect( negs, (intersect(abovea,aboveb)))]<-1
DR1T1C2$quad[intersect( negs, (intersect(belowa,aboveb)))]<-4
DR1T1C2$quad[intersect( negs, (intersect(abovea,belowb)))]<-2
DR1T1C2$quad[intersect( negs, (intersect(belowa,belowb)))]<-3
###Create function that determines which quadrants have pesticide
for (i in 1:length(DR1T1C2$quad)) {
r <- which(TrayPlace$Repetition==DR1T1C2$rep[i])
t <- which(TrayPlace$Trial==DR1T1C2$trial[i])
p <- which(TrayPlace$Position==DR1T1C2$position[i])
id <- intersect( p, intersect(r, t))
DR1T1C2$DishID[i] <- TrayPlace$DishID[id]
DR1T1C2$Orientation[i] <- TrayPlace$Orientation[id]
#there has to be a better way to do this
one   <- c(1,2,3,4)
two   <- c(2,3,4,1)
three <- c(3,4,1,2)
four  <- c(4,1,2,3)
OTab  <- data.frame(one, two, three, four)
Or    <- which(OTab$one==DR1T1C2$Orientation[i])
DR1T1C2$PQuad[i] <- OTab[Or, DR1T1C2$Orientation[i]]
#I'm pretty sure the above 7 lines could be two.
}
DR1T1C2$quad<-NA
DR1T1C2$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
DR1T1C2
DR1T1C2$quad
DR1T1C2$quad<-1
DR1T1C2$quad
DR1T1C2$quad<-NA
poss
belowa
belowb
intersect(belowa,aboveb)
(intersect(belowa,aboveb))
intersect( poss, (intersect(belowa,aboveb)))
poss
intersect( negs, (intersect(belowa,aboveb)))
DR1T1C2$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
DR1T1C2$quad
DR1T1C2$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
DR1T1C2$quad[intersect( poss, (intersect(abovea,aboveb)))]<-4
DR1T1C2$quad[intersect( poss, (intersect(belowa,belowb)))]<-2
DR1T1C2$quad[intersect( poss, (intersect(abovea,belowb)))]<-3
DR1T1C2$quad[intersect( negs, (intersect(abovea,aboveb)))]<-1
DR1T1C2$quad[intersect( negs, (intersect(belowa,aboveb)))]<-4
DR1T1C2$quad[intersect( negs, (intersect(abovea,belowb)))]<-2
DR1T1C2$quad[intersect( negs, (intersect(belowa,belowb)))]<-3
DR1T1C2$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
DR1T1C2$quad
intersect( poss, (intersect(belowa,aboveb)))
for (i in 1:length(DR1T1C2$quad)) {
r <- which(TrayPlace$Repetition==DR1T1C2$rep[i])
t <- which(TrayPlace$Trial==DR1T1C2$trial[i])
p <- which(TrayPlace$Position==DR1T1C2$position[i])
id <- intersect( p, intersect(r, t))
DR1T1C2$DishID[i] <- TrayPlace$DishID[id]
DR1T1C2$Orientation[i] <- TrayPlace$Orientation[id]
#there has to be a better way to do this
one   <- c(1,2,3,4)
two   <- c(2,3,4,1)
three <- c(3,4,1,2)
four  <- c(4,1,2,3)
OTab  <- data.frame(one, two, three, four)
Or    <- which(OTab$one==DR1T1C2$Orientation[i])
DR1T1C2$PQuad[i] <- OTab[Or, DR1T1C2$Orientation[i]]
#I'm pretty sure the above 7 lines could be two.
}
uno<-which(DR1T1C2$PQuad==1)
dos<-which(DR1T1C2$PQuad==2)
tres<-which(DR1T1C2$PQuad==3)
cuatro<-which(DR1T1C2$PQuad==4)
DR1T1C2$Pesticide<-NA
DR1T1C2$Pesticide[uno]<-0
DR1T1C2$Pesticide[dos]<-1
DR1T1C2$Pesticide[tres]<-0
DR1T1C2$Pesticide[cuatro]<-1
}
Assign<-function(VidData, CoordData, trayData){
belowa <- which((VidData$y) <  (VidData$pred1))
abovea <- which((VidData$y) >= (VidData$pred1))
belowb <- which((VidData$y) <  (VidData$pred2))
aboveb <- which((VidData$y) >= (VidData$pred2))
NegSlope <- which(CoordData$TPX <  CoordData$BPX )
PosSlope <- which(CoordData$TPX >= CoordData$BPX )
negs<-which(is.na(match(NegSlope, VidData$trayn))==FALSE)
poss<-which(is.na(match(PosSlope, VidData$trayn))==FALSE)
# Determine Quadrants #change depending on slope of verticle line
# In cases of positive slopes
VidData$quad[intersect]<-NA
VidData$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
VidData$quad[intersect( poss, (intersect(abovea,aboveb)))]<-4
VidData$quad[intersect( poss, (intersect(belowa,belowb)))]<-2
VidData$quad[intersect( poss, (intersect(abovea,belowb)))]<-3
VidData$quad[intersect( negs, (intersect(abovea,aboveb)))]<-1
VidData$quad[intersect( negs, (intersect(belowa,aboveb)))]<-4
VidData$quad[intersect( negs, (intersect(abovea,belowb)))]<-2
VidData$quad[intersect( negs, (intersect(belowa,belowb)))]<-3
###Create function that determines which quadrants have pesticide
for (i in 1:length(VidData$quad)){
r <- which(trayData$Repetition==VidData$rep[i])
t <- which(trayData$Trial==VidData$trial[i])
p <- which(trayData$Position==VidData$position[i])
id <- intersect( p, intersect(r, t))
VidData$DishID[i] <- trayData$DishID[id]
VidData$Orientation[i] <- trayData$Orientation[id]
#there has to be a better way to do this
one   <- c(1,2,3,4)
two   <- c(2,3,4,1)
three <- c(3,4,1,2)
four  <- c(4,1,2,3)
OTab  <- data.frame(one, two, three, four)
Or    <- which(OTab$one==VidData$Orientation[i])
VidData$PQuad[i] <- OTab[Or, VidData$Orientation[i]]
#I'm pretty sure the above 7 lines could be two.
}
uno<-which(VidData$PQuad==1)
dos<-which(VidData$PQuad==2)
tres<-which(VidData$PQuad==3)
cuatro<-which(VidData$PQuad==4)
VidData$Pesticide[uno]<-0
VidData$Pesticide[dos]<-1
VidData$Pesticide[tres]<-0
VidData$Pesticide[cuatro]<-1
}
#=============
tryit<-Assign(VidData = DR1T1C2, CoordData = CoTbR1T1C2, trayData = TrayPlace)
Assign<-function(VidData, CoordData, trayData){
belowa <- which((VidData$y) <  (VidData$pred1))
abovea <- which((VidData$y) >= (VidData$pred1))
belowb <- which((VidData$y) <  (VidData$pred2))
aboveb <- which((VidData$y) >= (VidData$pred2))
NegSlope <- which(CoordData$TPX <  CoordData$BPX )
PosSlope <- which(CoordData$TPX >= CoordData$BPX )
negs<-which(is.na(match(NegSlope, VidData$trayn))==FALSE)
poss<-which(is.na(match(PosSlope, VidData$trayn))==FALSE)
# Determine Quadrants #change depending on slope of verticle line
# In cases of positive slopes
VidData$quad<-NA
VidData$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
VidData$quad[intersect( poss, (intersect(abovea,aboveb)))]<-4
VidData$quad[intersect( poss, (intersect(belowa,belowb)))]<-2
VidData$quad[intersect( poss, (intersect(abovea,belowb)))]<-3
VidData$quad[intersect( negs, (intersect(abovea,aboveb)))]<-1
VidData$quad[intersect( negs, (intersect(belowa,aboveb)))]<-4
VidData$quad[intersect( negs, (intersect(abovea,belowb)))]<-2
VidData$quad[intersect( negs, (intersect(belowa,belowb)))]<-3
###Create function that determines which quadrants have pesticide
for (i in 1:length(VidData$quad)){
r <- which(trayData$Repetition==VidData$rep[i])
t <- which(trayData$Trial==VidData$trial[i])
p <- which(trayData$Position==VidData$position[i])
id <- intersect( p, intersect(r, t))
VidData$DishID[i] <- trayData$DishID[id]
VidData$Orientation[i] <- trayData$Orientation[id]
#there has to be a better way to do this
one   <- c(1,2,3,4)
two   <- c(2,3,4,1)
three <- c(3,4,1,2)
four  <- c(4,1,2,3)
OTab  <- data.frame(one, two, three, four)
Or    <- which(OTab$one==VidData$Orientation[i])
VidData$PQuad[i] <- OTab[Or, VidData$Orientation[i]]
#I'm pretty sure the above 7 lines could be two.
}
uno<-which(VidData$PQuad==1)
dos<-which(VidData$PQuad==2)
tres<-which(VidData$PQuad==3)
cuatro<-which(VidData$PQuad==4)
VidData$Pesticide[uno]<-0
VidData$Pesticide[dos]<-1
VidData$Pesticide[tres]<-0
VidData$Pesticide[cuatro]<-1
}
tryit<-Assign(VidData = DR1T1C2, CoordData = CoTbR1T1C2, trayData = TrayPlace)
tryit
View(tryit)
Assign<-function(VidData, CoordData, trayData){
belowa <- which((VidData$y) <  (VidData$pred1))
abovea <- which((VidData$y) >= (VidData$pred1))
belowb <- which((VidData$y) <  (VidData$pred2))
aboveb <- which((VidData$y) >= (VidData$pred2))
NegSlope <- which(CoordData$TPX <  CoordData$BPX )
PosSlope <- which(CoordData$TPX >= CoordData$BPX )
negs<-which(is.na(match(NegSlope, VidData$trayn))==FALSE)
poss<-which(is.na(match(PosSlope, VidData$trayn))==FALSE)
# Determine Quadrants #change depending on slope of verticle line
# In cases of positive slopes
VidData$quad<-NA
VidData$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
VidData$quad[intersect( poss, (intersect(abovea,aboveb)))]<-4
VidData$quad[intersect( poss, (intersect(belowa,belowb)))]<-2
VidData$quad[intersect( poss, (intersect(abovea,belowb)))]<-3
VidData$quad[intersect( negs, (intersect(abovea,aboveb)))]<-1
VidData$quad[intersect( negs, (intersect(belowa,aboveb)))]<-4
VidData$quad[intersect( negs, (intersect(abovea,belowb)))]<-2
VidData$quad[intersect( negs, (intersect(belowa,belowb)))]<-3
###Create function that determines which quadrants have pesticide
for (i in 1:length(VidData$quad)){
r <- which(trayData$Repetition==VidData$rep[i])
t <- which(trayData$Trial==VidData$trial[i])
p <- which(trayData$Position==VidData$position[i])
id <- intersect( p, intersect(r, t))
VidData$DishID[i] <- trayData$DishID[id]
VidData$Orientation[i] <- trayData$Orientation[id]
#there has to be a better way to do this
one   <- c(1,2,3,4)
two   <- c(2,3,4,1)
three <- c(3,4,1,2)
four  <- c(4,1,2,3)
OTab  <- data.frame(one, two, three, four)
Or    <- which(OTab$one==VidData$Orientation[i])
VidData$PQuad[i] <- OTab[Or, VidData$Orientation[i]]
#I'm pretty sure the above 7 lines could be two.
}
uno<-which(VidData$PQuad==1)
dos<-which(VidData$PQuad==2)
tres<-which(VidData$PQuad==3)
cuatro<-which(VidData$PQuad==4)
VidData$Pesticide[uno]<-0
VidData$Pesticide[dos]<-1
VidData$Pesticide[tres]<-0
VidData$Pesticide[cuatro]<-1
return(VidData)
}
#=============
tryit<-Assign(VidData = DR1T1C2, CoordData = CoTbR1T1C2, trayData = TrayPlace)
tryit
View(tryit)
poss, (intersect(belowa,aboveb)))
intersect( poss, (intersect(belowa,aboveb)))
negs, (intersect(abovea,aboveb)))
intersect( negs, (intersect(abovea,aboveb)))
intersect( negs, (intersect(belowa,aboveb)))
intersect( negs, (intersect(abovea,belowb)))
negs, (intersect(belowa,belowb)))
negs
pos
poss
intersect( poss, (intersect(abovea,aboveb)))
intersect( poss, (intersect(belowa,belowb)))
DR1T1C2$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
DR1T1C2$quad<-NA
DR1T1C2$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
DR1T1C2$quad[intersect( poss, (intersect(abovea,aboveb)))]<-4
DR1T1C2$quad[intersect( poss, (intersect(belowa,belowb)))]<-2
DR1T1C2$quad[intersect( poss, (intersect(abovea,belowb)))]<-3
DR1T1C2$quad[intersect( negs, (intersect(abovea,aboveb)))]<-1
DR1T1C2$quad[intersect( negs, (intersect(belowa,aboveb)))]<-4
DR1T1C2$quad[intersect( negs, (intersect(abovea,belowb)))]<-2
DR1T1C2$quad[intersect( negs, (intersect(belowa,belowb)))]<-3
View(DR1T2C2)
View(DR1T2C2)
View(DR1T1C2)
Assign<-function(VidData, CoordData, trayData){
belowa <- which((VidData$y) <  (VidData$pred1))
abovea <- which((VidData$y) >= (VidData$pred1))
belowb <- which((VidData$y) <  (VidData$pred2))
aboveb <- which((VidData$y) >= (VidData$pred2))
NegSlope <- which(CoordData$TPX <  CoordData$BPX )
PosSlope <- which(CoordData$TPX >= CoordData$BPX )
negs<-which(is.na(match(NegSlope, VidData$trayn))==FALSE)
poss<-which(is.na(match(PosSlope, VidData$trayn))==FALSE)
# Determine Quadrants #change depending on slope of verticle line
# In cases of positive slopes
VidData$quad<-NA
VidData$quad[intersect( poss, (intersect(belowa,aboveb)))]<-1
VidData$quad[intersect( poss, (intersect(abovea,aboveb)))]<-4
VidData$quad[intersect( poss, (intersect(belowa,belowb)))]<-2
VidData$quad[intersect( poss, (intersect(abovea,belowb)))]<-3
VidData$quad[intersect( negs, (intersect(abovea,aboveb)))]<-1
VidData$quad[intersect( negs, (intersect(belowa,aboveb)))]<-4
VidData$quad[intersect( negs, (intersect(abovea,belowb)))]<-2
VidData$quad[intersect( negs, (intersect(belowa,belowb)))]<-3
###Create function that determines which quadrants have pesticide
for (i in 1:length(VidData$quad)){
r <- which(trayData$Repetition==VidData$rep[i])
t <- which(trayData$Trial==VidData$trial[i])
p <- which(trayData$Position==VidData$position[i])
id <- intersect( p, intersect(r, t))
VidData$DishID[i] <- trayData$DishID[id]
VidData$Orientation[i] <- trayData$Orientation[id]
#there has to be a better way to do this
one   <- c(1,2,3,4)
two   <- c(2,3,4,1)
three <- c(3,4,1,2)
four  <- c(4,1,2,3)
OTab  <- data.frame(one, two, three, four)
Or    <- which(OTab$one==VidData$Orientation[i])
VidData$PQuad[i] <- OTab[Or, VidData$Orientation[i]]
#I'm pretty sure the above 7 lines could be two.
}
uno<-which(VidData$PQuad==1)
dos<-which(VidData$PQuad==2)
tres<-which(VidData$PQuad==3)
cuatro<-which(VidData$PQuad==4)
VidData$Pesticide[uno]<-0
VidData$Pesticide[dos]<-1
VidData$Pesticide[tres]<-0
VidData$Pesticide[cuatro]<-1
return(VidData)
}
#=============
tryit<-Assign(VidData = DR1T1C2, CoordData = CoTbR1T1C2, trayData = TrayPlace)
View(tryit)
