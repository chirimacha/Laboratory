?install.R
library(installR)
library(install.R)
library(updateR)
library(update.R)
version()
a<-1
b<-2
a+b
install.packages("videoplayR")
??videoplayR
install.packages("OpenCV")
if (!require(devtools)) {
install.packages("devtools")
}
devtools::install_github("swarm-lab/videoplayR")
library(videoplayR)
library(devtools)
devtools::install_github("swarm-lab/videoplayR")
devtools::install_github("swarm-lab/videoplayR")
devtools::install_github("swarm-lab/videoplayR")
install.packages("lippicv")
install.packages("-lippicv")
install.packages("videoplayR")
if (!require(devtools)) {
install.packages("devtools")
}
devtools::install_github("swarm-lab/videoplayR")
library(videoplayR)
devtools::install_github("swarm-lab/videoplayR")
install.packages("devtools")
install.packages("devtools")
devtools::install_github("swarm-lab/videoplayR")
if (!require(devtools)) {
install.packages("devtools")
}
devtools::install_github("swarm-lab/videoplayR")
#install Other packages:
install.packages("dplyr")
install.packages("clue")
install.packages("shiny")
install.packages("splancs")
#Open Libraries
library(videoplayR)
library(dplyr)
library(clue)
library(shiny)
library(splancs)
###Set Working Directory
#WD connected to github.
setwd("/Users/mzlevy/Laboratory/Inesfly_Paint_Bed_Bug_Trial/Pesticide_Detection")
fps <- (i - oldFrame + 1) / as.numeric(difftime(newTime, oldTime, unit = "secs"))
#Simple Tracker Code(package not available for new R)
pdiff <- function(a, b) {
nr <- length(a)
nc <- length(b)
ma <- matrix(a, nrow = nr, ncol = nc)
mb <- matrix(b, nrow = nr, ncol = nc, byrow = TRUE)
ma - mb
}
# declare variables in the function name
# what are current and past? defined elsewhere?
simpleTracker <- function(current, past, lookBack = 30, maxDist = 10) { #assign lookBack and maxDist w/ immutable numbers?
if (nrow(past) == 0) {
current$track <- 1:nrow(current)
return(current)
}
i <- current$frame[1]
trackCounter <- max(past$track)
# past <- dplyr::filter(past, frame > (i - lookBack), frame < i)
mat <- abs(pdiff(current$x, past$x)) + abs(pdiff(current$y, past$y))
maxMat <- matrix(maxDist * (i - past$frame), nrow = nrow(current), ncol = nrow(past), byrow = TRUE)
validMat <- mat <= maxMat
h <- as.vector(clue::solve_LSAP(mat))
tracks <- past$track[h]
valid <- validMat[(h - 1) * nrow(mat) + 1:nrow(mat)]
if (any(!valid)) {
nNew <- sum(!valid)
tracks[!valid] <- trackCounter + 1:nNew
trackCounter <- trackCounter + nNew
}
dup <- duplicated(tracks) | duplicated(tracks, fromLast = TRUE)
safe <- !dup
h[safe] <- 0
while (any(dup)) {
safe[which.max(h)] <- TRUE
h[safe] <- 0
newCurrent <- current[!safe, ]
newPast <- dplyr::filter(past, !(track %in% tracks[safe]))
if (nrow(newCurrent) > nrow(newPast)) {
n <- nrow(newCurrent) - nrow(newPast)
newPast <- rbind(newPast, data.frame(id = NA, x = rep(-9999, n), y = rep(-9999, n),
alpha = NA, major = NA, minor = NA, area = NA,
frame = newCurrent$frame[1], track = NA))
}
mat <- abs(pdiff(newCurrent$x, newPast$x)) + abs(pdiff(newCurrent$y, newPast$y))
maxMat <- matrix(maxDist * (i - newPast$frame), nrow = nrow(newCurrent),
ncol = nrow(newPast), byrow = TRUE)
validMat <- mat <= maxMat
newH <- as.vector(clue::solve_LSAP(mat))
newTracks <- newPast$track[newH]
valid <- validMat[(newH - 1) * nrow(mat) + 1:nrow(mat)]
if (any(!valid)) {
nNew <- sum(!valid)
newTracks[!valid] <- trackCounter + 1:nNew
trackCounter <- trackCounter + nNew
}
tracks[!safe] <- newTracks
dup <- duplicated(tracks) | duplicated(tracks, fromLast = TRUE)
safe <- !dup
h[safe] <- 0
}
current$track <- tracks
current
}
pipeline <- function(video, begin, end, background, mask = NULL,
threshold, minSize, lookBack, maxDist, progress = FALSE) {
n <- (end - begin + 1)
tracks <- data.frame(id = numeric(n), x = numeric(n), y = numeric(n),
alpha = numeric(n), major = numeric(n), minor = numeric(n),
area = numeric(n), frame = numeric(n) - 2 * lookBack, track = numeric(n))
pos <- 0
if (progress) {
pb <- shiny::Progress$new()
on.exit(pb$close())
pb$set(message = "Computing tracks", value = 0, detail = "0%")
nFrames <- length(begin:end)
old <- 0
oldFrame <- begin
oldTime <- Sys.time()
}
for (i in begin:end) {
past <- dplyr::filter(tracks, frame > (i - lookBack) & frame < i)
tmp <- getFrame(video, i) %>%
ddd2d() %>%
blend(background, ., "-") %>%
{if (is.null(mask)) . else blend(., mask, "*")} %>%
thresholding(threshold, "binary") %>%
blobDetector() %>%
dplyr::filter(area >= minSize) %>%
dplyr::mutate(frame = i, track = NA) %>%
{if (length(.$x) > 0)
trackR::simpleTracker(., past, lookBack = lookBack, maxDist = maxDist)
else . }
nRows <- nrow(tmp)
if (nRows > 0) {
if ((pos + nRows) > n) {
tracks[(n + 1):(2 * n + nRows), ] <- 0
n <- nrow(tracks)
}
tracks[(pos + 1):(pos + nRows), ] <- tmp
pos <- pos + nRows
}
if (progress) {
new <- floor(100 * (i - begin + 1) / nFrames)
if (new > old) {
newTime <- Sys.time()
fps <- (i - oldFrame + 1) / as.numeric(difftime(newTime, oldTime, unit = "secs"))
old <- new
oldFrame <- i
oldTime <- newTime
pb$set(value = old / 100, detail = paste0(old, "% - ", round(fps, digits = 2), "fps"))
}
}
}
tracks[1:pos, ]
}
pilotvidr1 <- readVid("PilotPetriRound1.mp4")
bg <- backgrounder(pilotvidr1, n = 100, method = "mean", color = FALSE)
bugpos<- data.frame()
mat <- matrix(0, nrow = bg$dim[1], ncol = bg$dim[2])
mat[150:400, 50:280] <- 1
imshow(bg)
imshow(mat)
pmaska <- (r2img(mat))
pmaska <- (r2img(mat))
show(pmaska)
imshow(pmaska)
nbga<-blend(bg, pmaska, "*")
imshow(nbga)
bugpos<- data.frame()
bugpos<- data.frame()
#Loop over each frame in the video.
for (i in 1:pilotvidr1$length){
#extract individual frames
res<-getFrame(pilotvidr1, i)
#put frame into grey scale.
gryscl <- ddd2d(res)
#mask other petri dishes
mask<-blend(gryscl, pmask, "*")
#subtract background from the mask. Only movement will show
sub<-blend(nbg, mask, "-")
#set a threshold difference to remove changes due to glare/reflection
bw<-thresholding(sub, 70, "binary")
#detect the black blobs that are created. Get coordinates
bugcords<-blobDetector(bw)
# add track # to data frame
bugcords<-mutate(bugcords, frame = i, track = NA)
#determines what points are linked. Optimally each insect given 1 track each
#because there is only one object, we can max out maxDist.
stout<-simpleTracker(past = bugpos, current = bugcords,maxDist=100)
#combine tables previous in the loop.
bugpos<- rbind(bugpos, stout)
}
for (i in 1:pilotvidr1$length){
#extract individual frames
res<-getFrame(pilotvidr1, i)
#put frame into grey scale.
gryscl <- ddd2d(res)
#mask other petri dishes
mask<-blend(gryscl, pmaska, "*")
#subtract background from the mask. Only movement will show
sub<-blend(nbg, mask, "-")
#set a threshold difference to remove changes due to glare/reflection
bw<-thresholding(sub, 70, "binary")
#detect the black blobs that are created. Get coordinates
bugcords<-blobDetector(bw)
# add track # to data frame
bugcords<-mutate(bugcords, frame = i, track = NA)
#determines what points are linked. Optimally each insect given 1 track each
#because there is only one object, we can max out maxDist.
stout<-simpleTracker(past = bugpos, current = bugcords,maxDist=100)
#combine tables previous in the loop.
bugpos<- rbind(bugpos, stout)
}
rev<-getFrame(pilotvidr1, 5)
imshow(rev)
grscl<-ddd2d(rev)
imshow(grscl)
mask<-blend(grscl, pmask, "*")
pmaska
mask<-blend(grscl, pmaska, "*")
imshow(mask)
neg<-blend(nbg, mask, "-") #the order matters
neg<-blend(nbga, mask, "-") #the order matters
imshow(neg)
ths<-thresholding(neg, 60, "binary")
imshow(ths)
bugloc<-blobDetector(ths)
bugloc
bcoutputx<-mutate(bugloc, frame=5, track=NA)
stoutx<-simpleTracker(bcoutputx, past=bugpos, maxDist= 10)
stoutx
for (i in 1:pilotvidr1$length){
#extract individual frames
res<-getFrame(pilotvidr1, i)
#put frame into grey scale.
gryscl <- ddd2d(res)
#mask other petri dishes
mask<-blend(gryscl, pmaska, "*")
#subtract background from the mask. Only movement will show
sub<-blend(nbga, mask, "-")
#set a threshold difference to remove changes due to glare/reflection
bw<-thresholding(sub, 70, "binary")
#detect the black blobs that are created. Get coordinates
bugcords<-blobDetector(bw)
# add track # to data frame
bugcords<-mutate(bugcords, frame = i, track = NA)
#determines what points are linked. Optimally each insect given 1 track each
#because there is only one object, we can max out maxDist.
stout<-simpleTracker(past = bugpos, current = bugcords,maxDist=100)
#combine tables previous in the loop.
bugpos<- rbind(bugpos, stout)
}
